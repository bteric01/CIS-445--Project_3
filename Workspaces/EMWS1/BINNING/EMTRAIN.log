MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 05, 
2015" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "14:10:38" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Log";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Training Log
Date:                November 05, 2015
Time:                14:10:38
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O0AA8H2T 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMTRAIN.out"
 encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O0AA8H2T new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMLOG.log" 
encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 05, 
2015" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "14:10:38" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                bteric01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Site:                70080760";
MPRINT(EM_DIAGRAM):   put "Platform:            X64_7PRO";
MPRINT(EM_DIAGRAM):   put "Maintenance Release: 9.04.01M1P120413";
MPRINT(EM_DIAGRAM):   put "EM Version:          13.1";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMTRAIN.log"
 encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMSCORE.log"
 encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMREPORT.log
" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMOUTPUT.out
" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 05, 
2015" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "14:10:38" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                bteric01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMTRAIN.out"
 encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Score Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMSCORE.out"
 encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Report Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMREPORT.out
" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 
'C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\EMRUNSTATUS.
xml' encoding="UTF-8" NOBOM;
104682     proc freq data=EMWS1.BINNING_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS1.BINNING_VariableSet noprint;
104683     table ROLE*LEVEL/out=WORK.BINNINGMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.BINNINGMETA;
104684     run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 24 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.BINNINGMETA has 5 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

104685     proc print data=WORK.BINNINGMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.BINNINGMETA label noobs;
104686     var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
104687     label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL =
104687   ! "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT =
104687   ! "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Role" LEVEL = "Measurement Level" COUNT = "Frequency 
Count";
104688     title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
104689     title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Variable Summary";
MPRINT(EM_DIAGRAM):   run;
104690     run;

NOTE: There were 5 observations read from the data set WORK.BINNINGMETA.
NOTE: The PROCEDURE PRINT printed page 49.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

104691     title10;
MPRINT(EM_DIAGRAM):   title10;
104692     %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE 
or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'Project_3';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'Diagram_3';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   set EMWS1.Ids_EMINFO;
MPRINT(EM_DIAGRAM):   where key in('HPDMSAMPLE', 'IDSTABLE');
MPRINT(EM_DIAGRAM):   if key = 'HPDMSAMPLE' then call symput('_ForceGrid', '1');
MPRINT(EM_DIAGRAM):   else call symput('_IDS_TABLE', DATA);
MPRINT(EM_DIAGRAM):   run;
MPRINT(HPDM_PERFORMANCE):  ;
PERFORMANCE  DETAILS
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
105054     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
105055     * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
105056     * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE 
or _ALL_;
105057     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

105058     %let EMEXCEPTIONSTRING=;
105059     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
105060     * TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   * TRAIN: BINNING;
105061     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
105062     %let EM_ACTION = TRAIN;
105063     %let syscc = 0;
105064     %macro main;
105065     
105066       filename temp catalog 'sashelp.emmdfy.binning_macros.source';
105067       %include temp;
105068       filename temp;
105069     
105070       %setProperties;
105071     
105072       %if %upcase(&EM_ACTION) = CREATE %then %do;
105073         filename temp catalog 'sashelp.emmdfy.binning_create.source';
105074         %include temp;
105075         filename temp;
105076     
105077         %create;
105078       %end;
105079     
105080        %else
105081        %if %upcase(&EM_ACTION) = TRAIN %then %do;
105082     
105083            filename temp catalog 'sashelp.emmdfy.binning_train.source';
105084            %include temp;
105085            filename temp;
105086            %train;
105087        %end;
105088     
105089       %else
105090       %if %upcase(&EM_ACTION) = SCORE %then %do;
105091         filename temp catalog 'sashelp.emmdfy.binning_score.source';
105092         %include temp;
105093         filename temp;
105094     
105095         %score;
105096     
105097       %end;
105098     
105099       %else
105100       %if %upcase(&EM_ACTION) = REPORT %then %do;
105101     
105102            filename temp catalog 'sashelp.emmdfy.binning_report.source';
105103            %include temp;
105104            filename temp;
105105     
105106            %report;
105107        %end;
105108     
105109        %doendm:
105110     %mend main;
105111     
105112     %main;
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_macros.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_MACROS.SOURCE.
105113    +
105114    +%macro SetProperties;
105115    +
105116    +     /* IGN options */
105117    +     %em_checkmacro(name=EM_PROPERTY_APPLYLEVELRULE, value=N, global=Y);
105118    +     %em_checkmacro(name=EM_PROPERTY_BINMETHOD,  value=QUANTILE, global=Y);
105119    +     %em_checkmacro(name=EM_PROPERTY_NUMBINS,    value=4, global=Y);
105120    +
105121    +     %em_checkmacro(name=EM_PROPERTY_MISSINGASLEVEL, value=Y, global=Y);
105122    +     %em_checkmacro(name=EM_PROPERTY_PRECISION,    value=2, global=Y);
105123    +     %em_checkmacro(name=EM_PROPERTY_CREATEGROUPING, value=N, global=Y);
105124    +     %em_checkmacro(name=EM_PROPERTY_CREATEMETHOD, value=OVERWRITE, global=Y);
105125    +     %em_checkmacro(name=EM_PROPERTY_IMPORTGROUPING, value=N, global=Y);
105126    +     %em_checkmacro(name=EM_PROPERTY_IMPORTDATA, value=, global=Y);
105127    +     %em_checkmacro(name=EM_PROPERTY_FREEZE, value=N, global=Y);
105128    +     %em_checkmacro(name=EM_PROPERTY_VARSELMETHOD, value=GINI, global=Y);
105129    +     %em_checkmacro(name=EM_PROPERTY_GINICUTOFF,   value=20.0, global=Y);
105130    +     %em_checkmacro(name=EM_PROPERTY_GRPMSMNT,     value=ORDINAL, global=Y);
105131    +     %em_checkmacro(name=EM_PROPERTY_MAXVAR,       value=10, global=Y);
105132    +     %em_checkmacro(name=EM_PROPERTY_CLASSGROUPRARE, value=Y, global=Y);
105133    +     %em_checkmacro(name=EM_PROPERTY_GROUPCUTOFF,    value=0.5, global=Y);
105134    +     %em_checkmacro(name=EM_PROPERTY_GROUPMISSING,   value=N, global=Y);
105135    +
105136    +     %em_checkmacro(name=EM_PROPERTY_INTTARGETMETHOD, value=CUTMEAN, global=Y);
105137    +     %em_checkmacro(name=EM_PROPERTY_USERCUTVALUE, value=0.2, global=Y);
105138    +     %em_checkmacro(name=EM_PROPERTY_RejectIntTarget, value=N, global=Y);
105139    +
105140    +
105141    +%mend SetProperties;
105142    +%macro appendfiles(fileref1, fileref2);
105143    +     data _null_;
105144    +       length c $256;
105145    +       fid1=fopen("&fileref1",'A');
105146    +       fid2=fopen("&fileref2",'I');
105147    +       cval = finfo(fid2,'lrecl');
105148    +       put cval= fid1= fid2=;
105149    +       if (fid2 > 0) then
105150    +         do while(fread(fid2)=0);
105151    +           rc = fget(fid2,c,256);
105152    +           _msg_=sysmsg();
105153    +           /* put rc= c= _msg_=; */
105154    +           rc = fput(fid1,strip(c));
105155    +           rc = fwrite(fid1);
105156    +         end;
105157    +         _msg_=sysmsg();
105158    +         put _msg_=;
105159    +       rc = fclose(fid1);
105160    +       rc = fclose(fid2);
105161    +     run;
105162    +%mend appendfiles;
105163    +
105164    +%macro buildOptScoreCode;
105165    +
105166    +    %em_register(key=BINCODE, type=FOLDER);
105167    +
105168    +    filename x catalog 'sashelp.emutil.em_deldir.source';
105169    +    %inc x;
105170    +    filename x;
105171    +    %delDir(folder=%nrbquote(&em_user_bincode));
105172    +
105173    +    data _null_; length rc $200;
105174    +       rc = dcreate('BINCODE', "&EM_NODEDIR");
105175    +    run;
105176    +
105177    +    %if ^%sysfunc(exist(class_nosv)) %then %goto doendu;
105178    +
105179    +    %let dsid = %sysfunc(open(class_nosv));
105180    +    %let nameNum    = %sysfunc(varnum(&dsid, DISPLAY_VAR));
105181    +    %let grpnameNum = %sysfunc(varnum(&dsid, _grp_variable_));
105182    +
105183    +    %let oldname=;
105184    +    %do %while(^%sysfunc(fetch(&dsid)));
105185    +        %let name    = %sysfunc(getvarc(&dsid, &nameNum));
105186    +        %let grpname = %sysfunc(getvarc(&dsid, &grpnameNum));
105187    +
105188    +        %if &name ne &oldname %then %do;
105189    +             filename _F1 "&em_user_bincode&em_dsep.&grpname..sas" MOD;
105190    +             data _null_;
105191    +                length string $200 flag endflag 8;
105192    +                retain string flag endflag;
105193    +                set class_nosv end=eof;
105194    +                where DISPLAY_VAR ="&name";
105195    +                by _variable_ _group_;
105196    +                file _F1;
105197    +                index = kindex(_variable_, "BIN_");
105198    +                if index gt 0 then do;
105199    +                   if first._variable_ then do;
105200    +                      put ' ';
105201    +                      put "&EM_CODEBAR;";
105202    +                      string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
105203    +                      put string;
105204    +                      put "&EM_CODEBAR;";
105205    +
105206    +                      if origLabel ne "" then do;
105207    +                            string = 'LABEL '!!strip(_grp_variable_)!!' = ';
105208    +                            put string;
105209    +                            string = tranwrd(origLabel,"'","''");
105210    +                            string = "'Grouped: "!!%nrbquote(strip(substr(string,
105210   !+1,188)))!!"';";
105211    +                            put string;
105212    +                      end;
105213    +                      else do;
105214    +                             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped:
105214   !+ '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
105215    +                             put string;
105216    +                      end;
105217    +
105218    +                      put ' ';
105219    +
105220    +                      string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
105221    +                      put string;
105222    +                      string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
105223    +                      put string;
105224    +                      put "end;";
105225    +                      string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then
105225   !+do;";
105226    +                      put string;
105227    +                   end;
105228    +                   if first._group_ then do;
105229    +                      flag = 0;
105230    +                      endflag = 1;
105231    +                      if ^first._variable_ then do;
105232    +                         put "else";
105233    +                      end;
105234    +                      if LB ne . then do;
105235    +                         string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
105236    +                      end;
105237    +                      else do;
105238    +                         flag = 1;
105239    +                         string = "if";
105240    +                      end;
105241    +                   end;
105242    +                   if last._Group_ then do;
105243    +                      if UB ne . then do;
105244    +                        if flag ne 1 then do;
105245    +                          string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" <
105245   !+"!!strip(UB)!!" then do;";
105246    +                        end;
105247    +                        else do;
105248    +                          string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!"
105248   !+then do;";
105249    +                        end;
105250    +                      end;
105251    +                      else do;
105252    +                         if flag=1 then do;
105253    +                            string = strip(DISPLAY_VAR) ;
105254    +                            string = strip(string)!!'='!!strip(_split_Value_)!!"
105254   !+then do;";
105255    +                            endflag=0;
105256    +                            string="";
105257    +                         end;
105258    +                         else do;
105259    +                            string = strip(string)!!" then do;";
105260    +                         end;
105261    +                      end;
105262    +                      put string;
105263    +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
105264    +                      put string;
105265    +                      if endflag eq 1 then do;
105266    +                        put "end;";
105267    +                      end;
105268    +                   end;
105269    +                   if last._variable_ then do;
105270    +                     string = "end;";
105271    +                     put string;
105272    +                   end;
105273    +
105274    +                end;
105275    +                else do;
105276    +                   _split_value_ = tranwrd(_split_value_,"'","''");
105277    +                   if first._group_ then do;
105278    +                      flag=0;
105279    +                      if ^first._variable_ then
105280    +                         put 'else';
105281    +                      else do;
105282    +                         put ' ';
105283    +                         put "&EM_CODEBAR;";
105284    +                         string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
105285    +                         put string;
105286    +                         put "&EM_CODEBAR;";
105287    +
105288    +                         if origLabel ne "" then do;
105289    +                               string = 'LABEL '!!strip(_grp_variable_)!!' = ';
105290    +                               put string;
105291    +                               string = tranwrd(origLabel,"'","''");
105292    +                               string = "'Grouped: "!!%nrbquote(strip(substr(string,
105292   !+ 1,188)))!!"';";
105293    +                               put string;
105294    +                         end;
105295    +                         else do;
105296    +                               string = 'LABEL '!!strip(_grp_variable_)!!' =
105296   !+"Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
105297    +                               put string;
105298    +                         end;
105299    +
105300    +                         put ' ';
105301    +
105302    +                         if format ne '' then do;
105303    +                            if first._variable_ then do;
105304    +                               string = "_UFormat =
105304   !+put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
105305    +                               put string;
105306    +                               string = '%dmnormip(_UFormat);';
105307    +                               put string;
105308    +
105309    +                               string ="if MISSING(_UFORMAT) then do;";
105310    +                               put string;
105311    +                               string = strip(_grp_variable_)!!" =
105311   !+"!!strip(MISSGRP)!!";";
105312    +                               put string;
105313    +                               put "end;";
105314    +
105315    +                               string="else if NOT MISSING(_UFORMAT) then do;";
105316    +                               put string;
105317    +
105318    +                            end;
105319    +                         end;
105320    +                         else do;
105321    +                            if type = 'N' then do;
105322    +                              string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;
105322   !+";
105323    +                              put string;
105324    +                              string = strip(_grp_variable_)!!" =
105324   !+"!!strip(MISSGRP)!!";";
105325    +                              put string;
105326    +                              put "end;";
105327    +
105328    +                              string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!")
105328   !+then do;";
105329    +                              put string;
105330    +                            end;
105331    +                            else if type='C' then do;
105332    +                              string = "_UFormat = "||strip(DISPLAY_VAR)||";";
105333    +                              put string;
105334    +                              string = '%dmnormip(_UFormat);';
105335    +                              put string;
105336    +
105337    +                              string ="if MISSING(_UFORMAT) then do;";
105338    +                              put string;
105339    +                              string = strip(_grp_variable_)!!" =
105339   !+"!!strip(MISSGRP)!!";";
105340    +                              put string;
105341    +                              put "end;";
105342    +
105343    +                              string="else if NOT MISSING(_UFORMAT) then do;";
105344    +                              put string;
105345    +                              string = '%dmnormip(_UFormat);';
105346    +                              put string;
105347    +                           end;
105348    +                         end;
105349    +                      end;
105350    +                      if format ne '' OR type='C' then do;
105351    +                        string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
105352    +                      end;
105353    +                      else do;
105354    +                        string = "if ("!!strip(DISPLAY_VAR)!!" eq
105354   !+"!!strip(_split_value_);
105355    +                      end;
105356    +                   end;
105357    +                   else do;
105358    +                      if flag ne 1 then do;
105359    +                       if format ne '' OR type='C' then do;
105360    +                         tempstring = strip(string)!!" OR _UFORMAT eq
105360   !+'"!!strip(_split_value_)!!"'";
105361    +                       end;
105362    +                       else do;
105363    +                         tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!"
105363   !+eq "!!strip(_split_value_);
105364    +                       end;
105365    +                         length = length(tempstring);
105366    +
105367    +                         if length < 195 then do;
105368    +                            string = tempstring;
105369    +                         end;
105370    +                         else do;
105371    +
105372    +                            string = strip(string);
105373    +                            put string;
105374    +                            string = ") then do;";
105375    +                            put string;
105376    +
105377    +                            string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!"
105377   !+;";
105378    +                            put string;
105379    +                            put "end;";
105380    +
105381    +                            put 'else';
105382    +                            if format ne '' OR type='C' then do;
105383    +                              string = "if (_UFORMAT eq
105383   !+'"!!strip(_split_value_)!!"'";
105384    +                            end;
105385    +                            else do;
105386    +                              string = "if "!!strip(DISPLAY_VAR)!!" eq
105386   !+("!!strip(_split_value_);
105387    +                            end;
105388    +                         end;
105389    +                      end;
105390    +                   end;
105391    +
105392    +                   if last._group_ then do;
105393    +                      string = strip(string);
105394    +                      put string;
105395    +
105396    +                      string = ") then do;";
105397    +                      put string;
105398    +
105399    +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
105400    +                      put string;
105401    +                      put "end;";
105402    +                   end;
105403    +
105404    +                   if last._variable_ then do;
105405    +                     put "else do;";
105406    +
105407    +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
105408    +                     put string;
105409    +
105410    +                     put "end;";
105411    +                     put "end;";
105412    +                   end;
105413    +                end;
105414    +             run;
105415    +
105416    +             %let oldname = &name;
105417    +        %end;
105418    +    %end;
105419    +    %let dsid = %sysfunc(close(&dsid));
105420    +
105421    +    filename _F1 "&em_user_bincode&em_dsep._ALL_.sas";
105422    +    data _null_;
105423    +       file _F1;
105424    +       put "length _UFormat $200;";
105425    +       put "drop _UFormat;";
105426    +       put "_UFormat='';";
105427    +    run;
105428    +    filename _F1;
105429    +
105430    +   %em_register(key=EMSCOREVAR, type=DATA);
105431    +   %let scorevarDs = %scan(&em_user_emscorevar, 2, .);
105432    +   proc datasets lib=&em_lib nolist;
105433    +      delete &scorevarDs;
105434    +   run;
105435    +   quit;
105436    +
105437    +   %let filrf=mydir;
105438    +   %let rc=%sysfunc(filename(filrf,&em_user_bincode));
105439    +   %let did=%sysfunc(dopen(&filrf));
105440    +
105441    +   %if &did %then %do;  %PUT  did= &did;
105442    +       %let memcount=%sysfunc(dnum(&did));
105443    +       %if &memcount > 0 %then %do;
105444    +           data &em_user_emscorevar;
105445    +              length Name $32 formula $70 file $200;
105446    +              keep NAME Formula file;
105447    +              formula  = '';
105448    +           %if %sysfunc(fileexist(&em_user_bincode&em_dsep._ALL_.sas)) %then %do;
105449    +               name=''; file="BINCODE&em_dsep._ALL_.sas";
105450    +               output;
105451    +           %end;
105452    +           %do i=1 %to &memcount;
105453    +               %let name =%nrbquote(%sysfunc(dread(&did,&i)));
105454    +               %let newvar = %scan(&name, 1, .);
105455    +               %if "&newvar" ne "_ALL_" %then %do;
105456    +                   name = "&newvar"; file="BINCODE&em_dsep&name";
105457    +                   output;
105458    +               %end;
105459    +           %end;
105460    +
105461    +           run;
105462    +       %end;
105463    +       %let did = %sysfunc(dclose(&did));
105464    +  %end;
105465    +
105466    +   %doendu:
105467    +%mend buildOptScoreCode;
105468    +
105469    +
105470    +%macro buildScoreCode(flowCode, publishCode);
105471    +
105472    +
105473    +  filename x "&flowCode";
105474    +
105475    +  proc sort data=&EM_USER_SPLITVALS; by display_var _split_Value_; run;
105476    +  proc sort data=&EM_USER_BINMAPPINGS; by display_var bin; run;
105477    +  proc sort data=&EM_USER_coarse out=tempcoarse; by display_var _group_; run;
105478    +
105479    +  data temp;
105480    +    merge &EM_USER_SPLITVALS &EM_USER_BINMAPPINGS(rename=(BIN=_SPLIT_VALUE_
105480   !+BIN_NAME=_VARIABLE_));
105481    +    by display_var _Split_value_;
105482    +     if upcase(_Split_value_) ne 'MISSING';
105483    +   run;
105484    +
105485    +   data temp_missing;
105486    +     merge &EM_USER_SPLITVALS(rename=(_GROUP_=MISSGRP))
105486   !+&EM_USER_BINMAPPINGS(rename=(
105487    +          BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
105488    +     by display_var _Split_value_;
105489    +     if upcase(_Split_value_) eq 'MISSING';
105490    +     keep _variable_ display_var missgrp;
105491    +   run;
105492    +
105493    +   proc sort data=temp_missing; by display_var missgrp; run;
105494    +
105495    +   data temp_missing;
105496    +     merge temp_missing(in=_a) tempcoarse(rename=(_GROUP_=MISSGRP));
105497    +     by display_var missgrp;
105498    +     if ^_a then delete;
105499    +     keep _variable_ display_var missgrp ;
105500    +   run;
105501    +
105502    +   data temp;
105503    +     merge temp temp_missing;
105504    +     by display_var;
105505    +     if display_Var eq '' then delete;
105506    +    run;
105507    +
105508    +    /* pull in wtev values */
105509    +    proc sort data=&EM_USER_varmappings out=tempmappings; by _variable_; run;
105510    +    proc sort data=&EM_IMPORT_DATA_CMETA out=tempcmeta; by NAME; run;
105511    +    proc sort data=temp;  by display_var _group_; run;
105512    +
105513    +   data temp;
105514    +      merge temp tempcoarse(keep=display_var _group_  role) ;
105515    +      by display_var _group_;
105516    +    run;
105517    +
105518    +    data temp;
105519    +      merge temp tempmappings(rename=(_variable_ = display_var)) tempcmeta(keep=NAME
105519   !+ FORMAT TYPE LABEL rename=(NAME=display_var LABEL=origLabel));
105520    +      by display_var;
105521    +
105522    +      if _group_ = . then delete;
105523    +      if _variable_ = '' then delete;
105524    +    run;
105525    +
105526    +    proc sort data=temp out=class;
105527    +       by _variable_ _group_ LB;
105528    +    run;
105529    +
105530    +    data _null_;
105531    +      file X;
105532    +
105533    +      put "length _UFormat $200;";
105534    +      put "drop _UFormat;";
105535    +      put "_UFormat='';";
105536    +    run;
105537    +
105538    +    data class_nosv;
105539    +      set class;
105540    +      if upcase(role)="INPUT";
105541    +    run;
105542    +
105543    +    data _null_;
105544    +       file X MOD;
105545    +       length string $200 flag endflag 8;
105546    +       retain string flag endflag;
105547    +       set class_nosv end=eof;
105548    +       by _variable_ _group_;
105549    +
105550    +       index = kindex(_variable_, "BIN_");
105551    +       if index gt 0 then do;
105552    +
105553    +         if first._variable_ then do;
105554    +            put ' ';
105555    +            put "&EM_CODEBAR;";
105556    +            string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
105557    +            put string;
105558    +            put "&EM_CODEBAR;";
105559    +
105560    +
105561    +            if origLabel ne "" then do;
105562    +              string = 'LABEL '!!strip(_grp_variable_)!!' = ';
105563    +              put string;
105564    +              string = tranwrd(origLabel,"'","''");
105565    +              string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
105566    +              put string;
105567    +            end;
105568    +            else do;
105569    +             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped:
105569   !+'!!%nrbquote(strip(DISPLAY_VAR))!!'";';
105570    +             put string;
105571    +            end;
105572    +
105573    +            put ' ';
105574    +
105575    +            string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
105576    +            put string;
105577    +            string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
105578    +            put string;
105579    +            put "end;";
105580    +            string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
105581    +            put string;
105582    +          end;
105583    +           if first._group_ then do;
105584    +              flag = 0;
105585    +              endflag = 1;
105586    +              if ^first._variable_ then do;
105587    +                put "else";
105588    +              end;
105589    +              if LB ne . then do;
105590    +                 string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
105591    +              end;
105592    +              else do;
105593    +                 flag = 1;
105594    +                 string = "if";
105595    +              end;
105596    +
105597    +           end;
105598    +           if last._Group_ then do;
105599    +              if UB ne . then do;
105600    +                if flag ne 1 then do;
105601    +                  string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" <
105601   !+"!!strip(UB)!!" then do;";
105602    +                end;
105603    +                else do;
105604    +                  string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
105605    +                end;
105606    +              end;
105607    +              else do;
105608    +                 if flag=1 then do;
105609    +                   string = strip(DISPLAY_VAR) ;
105610    +                   string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
105611    +                   endflag = 0;
105612    +                   string="";
105613    +                 end;
105614    +                 else do;
105615    +                   string = strip(string)!!" then do;";
105616    +                 end;
105617    +              end;
105618    +              put string;
105619    +
105620    +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
105621    +              put string;
105622    +              if endflag eq 1 then do;
105623    +                put "end;";
105624    +              end;
105625    +           end;
105626    +           if last._variable_ then do;
105627    +             string = "end;";
105628    +             put string;
105629    +           end;
105630    +       end;
105631    +       else do;
105632    +           _split_value_ = tranwrd(_split_value_,"'","''");
105633    +           if first._group_ then do;
105634    +              flag=0;
105635    +              if ^first._variable_ then
105636    +                 put 'else';
105637    +              else do;
105638    +                 put ' ';
105639    +                 put "&EM_CODEBAR;";
105640    +                 string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
105641    +                 put string;
105642    +                 put "&EM_CODEBAR;";
105643    +
105644    +                 if origLabel ne "" then do;
105645    +                   string = 'LABEL '!!strip(_grp_variable_)!!' = ';
105646    +                   put string;
105647    +                   string = tranwrd(origLabel,"'","''");
105648    +                   string = "'Grouped: "!!%nrbquote(strip(substr(string,
105648   !+1,188)))!!"';";
105649    +                   put string;
105650    +                 end;
105651    +                 else do;
105652    +                   string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped:
105652   !+'!!%nrbquote(strip(DISPLAY_VAR))!!'";';
105653    +                   put string;
105654    +                 end;
105655    +
105656    +                 put ' ';
105657    +
105658    +                if format ne '' then do;
105659    +                  if first._variable_ then do;
105660    +                    string = "_UFormat =
105660   !+put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
105661    +                    put string;
105662    +                    string = '%dmnormip(_UFormat);';
105663    +                    put string;
105664    +
105665    +                     string ="if MISSING(_UFORMAT) then do;";
105666    +                     put string;
105667    +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
105668    +                     put string;
105669    +                     put "end;";
105670    +
105671    +                     string="else if NOT MISSING(_UFORMAT) then do;";
105672    +                     put string;
105673    +
105674    +                  end;
105675    +                end;
105676    +                else do;
105677    +                     if type = 'N' then do;
105678    +                       string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
105679    +                       put string;
105680    +                       string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
105681    +                       put string;
105682    +                       put "end;";
105683    +
105684    +                       string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do
105684   !+;";
105685    +                       put string;
105686    +
105687    +                     end;
105688    +                     else if type='C' then do;
105689    +                        string = "_UFormat = "||strip(DISPLAY_VAR)||";";
105690    +                        put string;
105691    +                        string = '%dmnormip(_UFormat);';
105692    +                        put string;
105693    +
105694    +                        string ="if MISSING(_UFORMAT) then do;";
105695    +                        put string;
105696    +                        string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
105697    +                        put string;
105698    +                        put "end;";
105699    +
105700    +                        string="else if NOT MISSING(_UFORMAT) then do;";
105701    +                        put string;
105702    +                        string = '%dmnormip(_UFormat);';
105703    +                        put string;
105704    +                    end;
105705    +                end;
105706    +              end;
105707    +              if format ne '' OR type='C' then do;
105708    +                string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
105709    +              end;
105710    +              else do;
105711    +                string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
105712    +              end;
105713    +           end;
105714    +           else do;
105715    +              if flag ne 1 then do;
105716    +                if format ne '' OR type='C' then do;
105717    +                  tempstring = strip(string)!!" OR _UFORMAT eq
105717   !+'"!!strip(_split_value_)!!"'";
105718    +                end;
105719    +                else do;
105720    +                  tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq
105720   !+"!!strip(_split_value_);
105721    +                end;
105722    +                length = klength(tempstring);
105723    +
105724    +                if length < 195 then do;
105725    +                   string = tempstring;
105726    +                end;
105727    +                else do;
105728    +
105729    +                   string = strip(string);
105730    +                   put string;
105731    +                   string = ") then do;";
105732    +                   put string;
105733    +
105734    +                   string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
105735    +                   put string;
105736    +                   put "end;";
105737    +
105738    +                 /*  string = strip(string)||",'...';"; */
105739    +
105740    +                   put 'else';
105741    +                   if format ne '' OR type='C' then do;
105742    +                     string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
105743    +                   end;
105744    +                   else do;
105745    +                     string = "if ("!!strip(DISPLAY_VAR)!!" eq
105745   !+"!!strip(_split_value_);
105746    +                   end;
105747    +
105748    +
105749    +                end;
105750    +              end;
105751    +           end;
105752    +
105753    +           if last._group_ then do;
105754    +              string = strip(string);
105755    +              put string;
105756    +              string = ") then do;";
105757    +              put string;
105758    +
105759    +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
105760    +              put string;
105761    +              put "end;";
105762    +           end;
105763    +
105764    +           if last._variable_ then do;
105765    +             put "else do;";
105766    +
105767    +             string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
105768    +             put string;
105769    +
105770    +             put "end;";
105771    +             put "end;";
105772    +           end;
105773    +         *end;
105774    +       end;
105775    +    run;
105776    +
105777    +    /* generate PublishCode the same as flowscorecode */
105778    +    filename Y "&publishCode";
105779    +
105780    +    /* if publishCode already exists, wipe it out first */
105781    +    %if %sysfunc(fexist(Y)) eq 1 %then %do;
105782    +      %let rc = %sysfunc(fdelete(Y));
105783    +    %end;
105784    +
105785    +    %appendfiles(Y, X);
105786    +
105787    +    %if %EM_BINARY_TARGET= %then %do;
105788    +      %if %symexist(EM_NUM_INTERVAL_TARGET)=0 %then %do;
105789    +         %em_varMacro(name=EM_INTERVAL_TARGET, metadata=&EM_DATA_variableSet,
105789   !+where=%nrbquote(ROLE="TARGET" and LEVEL="INTERVAL" and (USE="Y" or USE="D")),
105789   !+nummacro=em_num_interval_Target);
105790    +      %end;
105791    +      %let ibn_inttarget=%EM_INTERVAL_TARGET;
105792    +      %let ibn_inttarget_orig = &ibn_inttarget;
105793    +
105794    +      %if %symexist(IGNBinTarget)=0 %then %do;
105795    +         %global ignbintarget ignfreqvar;
105796    +         filename temp catalog 'sashelp.emutil.em_getvarname.source';
105797    +         %include temp;
105798    +         filename temp;
105799    +         %getVarName(&EM_IMPORT_DATA,
105799   !+BIN_%substr(&ibn_inttarget,1,%sysfunc(min(%length(&ibn_inttarget),28))),
105799   !+IGNBinTarget);
105800    +
105801    +         %if &EM_PROPERTY_INTTARGETMETHOD = DUPFREQ %then %do;
105802    +            %getVarName(&EM_IMPORT_DATA, _FREQ_, ignfreqvar);
105803    +         %end;
105804    +      %end;
105805    +      %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
105806    +         proc sql noprint;
105807    +            %if %EM_FREQ ne %then %do;
105808    +               select sum(&ibn_inttarget * %EM_FREQ) / sum(%EM_FREQ)
105809    +            %end;
105810    +            %else %do;
105811    +               select mean(&ibn_inttarget)
105812    +            %end;
105813    +            into :ignbincut trimmed from &EM_IMPORT_DATA;
105814    +         quit;
105815    +      %end;
105816    +
105817    +      %let dsid=%sysfunc(open(&EM_IMPORT_DATA,i));
105818    +      %if &dsid %then %do;
105819    +         %let
105819   !+tarlabel=%trim(%sysfunc(varlabel(&dsid,%sysfunc(varnum(&dsid,&ibn_inttarget)))));
105820    +         %let rc=%sysfunc(close(&dsid));
105821    +      %end;
105822    +      %if %length(&tarlabel)=0 %then %let tarlabel = &ibn_inttarget;
105823    +
105824    +      data _null_;
105825    +         file x mod;
105826    +         put ' ';
105827    +
105828    +         %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
105829    +             put "&EM_CODEBAR;";
105830    +             %let note = Mean Cutoff Binary Transformation for Target;
105831    +             put "* &note;";
105832    +             put "&EM_CODEBAR;";
105833    +         %end;
105834    +         %else %if &EM_PROPERTY_INTTARGETMETHOD = CUTUSER %then %do;
105835    +             put "&EM_CODEBAR;";
105836    +             %let note = User-Specified Cutoff Binary Transformation for Target;
105837    +             put "* &note;";
105838    +             put "&EM_CODEBAR;";
105839    +             %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
105840    +         %end;
105841    +         put "if &ibn_inttarget = . then &IGNBinTarget = .;";
105842    +         put "else do;";
105843    +         put "   if &ibn_inttarget > &ignbincut then &IGNBinTarget=1;";
105844    +         put "   else &IGNBinTarget=0;";
105845    +         put "end;";
105846    +
105847    +         put "label &IGNBinTarget = 'Binary: %nrbquote(%substr(&tarlabel,1,192))';";
105848    +      run;
105849    +
105850    +      filename deltaref "&EM_FILE_CDELTA_TRAIN";
105851    +
105852    +      %if &EM_PROPERTY_RejectIntTarget = Y %then %do;
105853    +
105854    +         data _null_;
105855    +            file deltaref;
105856    +            put "if name='&ibn_inttarget_orig' then role='REJECTED';";
105857    +            put "if name='&IGNBinTarget' then do;";
105858    +            put "   role='TARGET';";
105859    +            put "   level='BINARY';";
105860    +            put "end;";
105861    +         run;
105862    +
105863    +      %end;
105864    +      %else %do;
105865    +
105866    +         data _null_;
105867    +            file deltaref;
105868    +            put "if name='&ibn_inttarget_orig' then role='TARGET';";
105869    +            put "if name='&IGNBinTarget' then do;";
105870    +            put "   role='REJECTED';";
105871    +            put "   level='BINARY';";
105872    +            put "end;";
105873    +         run;
105874    +      %end;
105875    +
105876    +      filename deltaref;
105877    +
105878    +   %end;
105879    +
105880    +    filename X;
105881    +    filename Y;
105882    +
105883    +    %buildOptScoreCode;
105884    +
105885    +    proc datasets library=work nolist;
105886    +      delete class class_nosv temp temp_missing tempmappings tempcmeta;
105887    +    run;
105888    +    quit;
105889    +
105890    +%mend buildScoreCode;
105891    +
105892    +%macro buildMetaCode(DeltaCodeFile=);
105893    +
105894    +   /* set variable roles based on New Role column in the Results table */
105895    +   data _null_;
105896    +      file &DeltaCodeFile %if %length(%EM_BINARY_TARGET)=0 %then mod;;
105897    +      %let dsid = %sysfunc(open(&EM_USER_RESULTSTABLE));
105898    +      %if &dsid %then %do;
105899    +        %let obs = %sysfunc(fetch(&dsid));
105900    +        %let vnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
105901    +        %let rnum = %sysfunc(VARNUM(&dsid, _new_role_));
105902    +        %let ornum = %sysfunc(VARNUM(&dsid, _role_));
105903    +
105904    +        %do %while(&obs=0);
105905    +          %let inputname = %sysfunc(getvarc(&dsid, &vnum));
105906    +          %let role      = %upcase(%sysfunc(getvarc(&dsid, &rnum)));
105907    +          %let oldrole   = %upcase(%sysfunc(getvarc(&dsid, &ornum)));
105908    +
105909    +          /* retrieve grp and woe names from varmappings dataset */
105910    +          %let choice = _VARIABLE_ = "&inputname";
105911    +          %let cdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
105912    +          %let cobs = %sysfunc(fetchobs(&cdsid, 1));
105913    +          %let grpnum = %sysfunc(VARNUM(&cdsid, _GRP_VARIABLE_));
105914    +          %let grpname = %sysfunc(getvarc(&cdsid, &grpnum));
105915    +          %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
105916    +
105917    +          put "if name = '&inputname' then role='REJECTED';";
105918    +          %if "&role" ne "DEFAULT" %then %do;
105919    +            put "if name = '&grpname' then role='&role';";
105920    +          %end;
105921    +          %else %do;
105922    +            put "if name = '&grpname' then role='&oldrole';";
105923    +          %end;
105924    +          put "if name = '&grpname' then level='&EM_PROPERTY_GRPMSMNT';";
105925    +
105926    +          %let obs = %sysfunc(fetch(&dsid));
105927    +        %end;
105928    +      %end;
105929    +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105930    +   run;
105931    +
105932    +   /* drop all vars in the splitvals dataset that aren't present in the varmappings
105932   !+dataset */
105933    +   data _null_;
105934    +      file &DeltaCodeFile MOD;
105935    +
105936    +      %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
105937    +      %if &sdsid %then %do;
105938    +        %let sobs = %sysfunc(fetch(&sdsid));
105939    +        %do %while(&sobs=0);
105940    +          %let varnum = %sysfunc(VARNUM(&sdsid, _VARIABLE_));
105941    +          %let checkname = %sysfunc(getvarc(&sdsid, &varnum));
105942    +          %let dispvarnum = %sysfunc(VARNUM(&sdsid, DISPLAY_VAR));
105943    +          %let displayvar = %sysfunc(getvarc(&sdsid, &dispvarnum));
105944    +
105945    +          %let checkgrp = GRP_&checkname;
105946    +          %let lenname = %length(&checkgrp);
105947    +          %if %eval(&lenname-32) > 0 %then %do;
105948    +            %let checkgrp = %substr(&checkgrp, 1, 32);
105949    +          %end;
105950    +
105951    +          %let choice = _VARIABLE_ ="&checkname";
105952    +          %let vdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
105953    +
105954    +          /* if var not found in varmappings, delete variables; */
105955    +          /* this could happen when freeze=Y and vars in the frozen dataset aren't
105955   !+in the incoming training data */
105956    +          %if &vdsid eq 0 %then %do;
105957    +            put 'if name="&displayvar" then delete;';
105958    +            %let dispgrp = GRP_&displayvar;
105959    +            put 'if name="&dispgrp" then delete;';
105960    +          %end;
105961    +
105962    +          %if &vdsid > 0 %then %let vdsid = %sysfunc(close(&vdsid));
105963    +          %let sobs = %sysfunc(fetch(&sdsid));
105964    +        %end;
105965    +      %end;
105966    +      %if &sdsid > 0 %then %let sdsid= %sysfunc(close(&sdsid));
105967    +   run;
105968    +
105969    +%mend buildMetaCode;
105970    +
105971    +%macro EM_GENERATE_RESULTSTABLE(coarse, resultstable, varmappings);
105972    +
105973    +   proc sort data=&coarse out=sortedcoarse nodupkey;
105974    +     by display_var;
105975    +   run;
105976    +   proc sort data=&varmappings nodupkey;
105977    +     by _variable_;
105978    +   run;
105979    +   %if %sysfunc(exist(&resultstable, data)) %then %do;
105980    +     proc sort data=&resultstable; by display_var; run;
105981    +   %end;
105982    +
105983    +   data &resultstable (Keep = display_var _gini_  _role_ _new_role_ procLevel);
105984    +     merge sortedcoarse(in=_a) &varmappings(rename=(_Variable_ = DISPLAY_VAR))
105985    +     %if %sysfunc(exist(&resultstable, data)) %then %do;
105986    +        &resultstable (keep = display_var _new_role_ )
105987    +     %end;
105988    +     ;
105989    +     by display_var;
105990    +     length _role_ _new_role_ $10;
105991    +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel ,
105991   !+NOQUOTE))"
105992    +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_ginistatistic_vlabel ,
105992   !+NOQUOTE))"
105993    +           _role_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_calcrole_vlabel,
105993   !+NOQUOTE))"
105994    +           _new_role_ = "%sysfunc(sasmsg(sashelp.dmine, meta_NEWROLE_vlabel,
105994   !+NOQUOTE))"
105995    +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel ,
105995   !+NOQUOTE))"
105996    +           ;
105997    +
105998    +           %if &EM_PROPERTY_VARSELMETHOD eq GINI %then %do;
105999    +             if _gini_ < &EM_PROPERTY_GINICUTOFF then
106000    +                _role_ = "Rejected";
106001    +             else _role_ = "Input";
106002    +           %end;
106003    +           %else %do;
106004    +             _role_ = "Input";
106005    +           %end;
106006    +           if _new_role_ eq "" then _new_role_="Default";
106007    +      if ^_a then do;
106008    +        _gini_ = 0;
106009    +        _role_ = 'Rejected';
106010    +        if _new_role_ eq "" then _new_role_="Default";
106011    +      end;
106012    +   run;
106013    +   proc sort data=&EM_DATA_VARIABLESET out=outlabel(keep=NAME LABEL LEVEL
106013   !+rename=(NAME=display_var LABEL=_label_));
106014    +     by NAME;
106015    +   run;
106016    +   data outlabel;
106017    +     set outlabel;
106018    +     if _label_ = '' then _label_ = _variable_;
106019    +   run;
106020    +   data &resultstable;
106021    +     merge &resultstable(in=_a_) outlabel;
106022    +     by display_Var;
106023    +     if _a_ then output;
106024    +   run;
106025    +   proc datasets library=work nolist;
106026    +     delete sortedcoarse outlabel;
106027    +   run;
106028    +   quit;
106029    +   proc sort data=&resultstable nodupkey;
106030    +      by DESCENDING
106031    +        _gini_ display_Var;
106032    +   run;
106033    +   data &resultstable;
106034    +     set &resultstable;
106035    +
106036    +     label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel ,
106036   !+NOQUOTE))"
106037    +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel ,
106037   !+NOQUOTE))";
106038    +     giniOrder = _N_;
106039    +     _gini_ = round(_GINI_, .001);
106040    +     drop _variable_;
106041    +   run;
106042    +
106043    +   proc print data=&resultstable label;
106044    +   run;
106045    +
106046    +   /* merge role, infovalOrder or giniOrder back into Coarse table as well */
106047    +   data &coarse;
106048    +     set &coarse;
106049    +     length role $10;
106050    +     %let dsid = %sysfunc(open(&resultstable));
106051    +     %if &dsid %then %do;
106052    +       %let disnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
106053    +       %let rolenum = %sysfunc(VARNUM(&dsid, _ROLE_));
106054    +       %let orderNum = %sysfunc(VARNUM(&dsid, giniOrder));
106055    +
106056    +       %let obs = %sysfunc(fetch(&dsid));
106057    +       %do %while(&obs=0);
106058    +          %let displayvar = %sysfunc(getvarc(&dsid, &disnum));
106059    +          %let role       = %sysfunc(getvarc(&dsid, &rolenum));
106060    +          %let order = %sysfunc(getvarn(&dsid, &ordernum));
106061    +
106062    +           if DISPLAY_VAR = "&displayVar" then do;
106063    +            label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel ,
106063   !+ NOQUOTE))";
106064    +            giniOrder = &order;
106065    +            role = "&role";
106066    +          end;
106067    +
106068    +          %let obs = %sysfunc(fetch(&dsid));
106069    +       %end;
106070    +     %end;
106071    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106072    +   run;
106073    +
106074    +
106075    +%mend EM_GENERATE_RESULTSTABLE;
106076    +
106077    +%macro EM_GENERATE_EXPORTGROUP(exportGrouping, createMethod);
106078    +
106079    +    /* instantiate the zchar macro to be used in adding bin definition */
106080    +    filename _temp catalog 'sashelp.emmacs.zchar.source';
106081    +    %inc _temp;
106082    +    filename _temp;
106083    +
106084    +    proc sort data=&EM_USER_FINEDETAILDATA out=sortedfine;
106085    +      by _variable_ binFlag _group_ LB;
106086    +    run;
106087    +
106088    +    data tempExport;
106089    +      set sortedFine;
106090    +      by _variable_ binFlag _group_;
106091    +      length _split_value_ $200;
106092    +
106093    +      /* for all binned variables, need to modify the split value to original cutoff
106093   !+ as well as change level to interval */
106094    +      if binFlag = 0 then do;
106095    +        index = kindex(_variable_, "BIN_");
106096    +        if index gt 0 then do;
106097    +          _LEVEL_ = "INTERVAL";
106098    +        end;
106099    +        _Split_value_ = _split_value_;
106100    +        output;
106101    +      end;
106102    +      else do;
106103    +         * if last._group_ then do;
106104    +          index = kindex(_variable_, "BIN_");
106105    +          if index gt 0 then do;
106106    +            _LEVEL_ = "INTERVAL";
106107    +          end;
106108    +          _Split_value_ = %zchar(UB);
106109    +          output;
106110    +         * end;
106111    +      end;
106112    +
106113    +      rename display_Var = _variable_;
106114    +      keep display_var _level_ _group_ _split_value_ binFlag;
106115    +    run;
106116    +
106117    +    %if &CREATEMETHOD eq OVERWRITE %then %do;
106118    +       data &EXPORTGROUPING;
106119    +         set tempexport;
106120    +       run;
106121    +    %end;
106122    +    %else %do;
106123    +       /* determine if EXPORTGROUPING already exists */
106124    +       %if %sysfunc(exist(&EXPORTGROUPING, DATA)) %then %do;
106125    +         data &EXPORTGROUPING;
106126    +            set &EXPORTGROUPING tempexport;
106127    +         run;
106128    +       %end;
106129    +       %else %do;
106130    +         data &EXPORTGROUPING;
106131    +            set tempexport;
106132    +         run;
106133    +       %end;
106134    +    %end;
106135    +
106136    +    proc datasets lib=work nolist;
106137    +      delete sortedFine tempexport;
106138    +    run;
106139    +    quit;
106140    +
106141    +%mend EM_GENERATE_EXPORTGROUP;
106142    +
106143    +
106144    +
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(MAIN):  ;
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_TRAIN.SOURCE.
106147    +%macro train;
106149    +   /* include training macros */
106150    +   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
106151    +   %include trtemp;
106152    +   filename trtemp;
106154    +   /* trick IGN into thinking it is a model node to build decmeta; further down, set
106154   !+ %EM_MODEL ASSESS=N
106155    +   %let EM_TOOLTYPE = MODEL; */
106157    +   %if &EM_IMPORT_DATA eq %then %do;
106158    +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN, 1;
106159    +       %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, error_nodeTrainRawData_note ,
106159   !+NOQUOTE));
106160    +       %put &em_codebar;
106161    +       %put &errmsg;
106162    +       %put &em_codebar;
106163    +       %goto doendm;
106164    +   %end;
106166    +   %if  &EM_NUM_TARGET ne 1 %then %do;
106167    +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
106168    +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine,
106168   !+METADATA.USE1BINORINTTARGET_ERR  , NOQUOTE));
106169    +        %put &em_codebar;
106170    +        %put &errmsg;
106171    +        %put &em_codebar;
106172    +        %goto doendm;
106173    +   %end;
106175    +  %if  &EM_NUM_BINARY_TARGET ne 1 and &EM_NUM_INTERVAL_TARGET ne 1 %then %do;
106176    +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
106177    +        %put &em_codebar;
106178    +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,
106178   !+METADATA.USE1BINORINTTARGET_ERR, NOQUOTE));
106179    +        %put &errormsg;
106180    +        %put &em_codebar;
106181    +        %goto doendm;
106182    +   %end;
106184    +   /* Initialize property macro variables */
106185    +   %SetProperties;
106186    +   %EM_GETNAME(key=NEWTRAIN, type=DATA);
106188    +   /* check actual num of target levels */
106189    +   %let target_level = %EM_TARGET_LEVEL;
106190    +   %let target_var = %EM_TARGET;
106191    +   %if (&target_Level eq BINARY) %then %do;
106192    +      /* retrieve target information */
106193    +      /* does decmeta exist?  If not, retrieve target information elsewhere */
106194    +      %global target_event;
106195    +      %let target_event=;
106196    +      %if "&EM_DEC_DECMETA" eq "" %then %do;
106197    +        /* retrieve type and format from variableset */
106198    +        %let eventorder = DESC;
106199    +        data temp;
106200    +          set &EM_DATA_VARIABLESET;
106201    +          where NAME ="%EM_BINARY_TARGET";
106202    +        run;
106203    +        %let dsid = %sysfunc(open(work.temp));
106204    +        %if &dsid %then %do;
106205    +          %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
106206    +          %let formatnum = %sysfunc(VARNUM(&dsid, FORMAT));
106207    +          %let ordernum  = %sysfunc(VARNUM(&dsid, ORDER));
106208    +          %let obs = %sysfunc(fetchobs(&dsid, 1));
106209    +          %let Target_type = %sysfunc(getvarc(&dsid, &typenum));
106210    +          %let Target_Format = %sysfunc(getvarc(&dsid, &formatnum));
106211    +          %let Target_Order  = %sysfunc(getvarc(&dsid, &ordernum));
106212    +          %if &TARGET_ORDER  = ASC %then %let eventorder = ASC;
106213    +             %else
106214    +          %if &TARGET_ORDER  = DESC %then %let eventorder = DESC;
106215    +             %else
106216    +          %if &TARGET_ORDER  = FMTASC %then %let eventorder = ASCFMT;
106217    +             %else
106218    +          %if &TARGET_ORDER  = FMTDESC %then %let eventorder = DESFMT;
106219    +        %end;
106220    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106222    +        /* retrieve target_event and Target_nonEvent values */
106223    +        proc dmdb data=&EM_IMPORT_DATA(where=(^missing(%EM_BINARY_TARGET)))
106223   !+classout=EVENTOUT;
106224    +          target %EM_BINARY_TARGET;
106225    +          class  %EM_BINARY_TARGET(&eventorder);
106226    +        run;
106228    +        data _null_;
106229    +          dsid = open("EVENTOUT");
106230    +          if dsid>0 then do;
106231    +          levelnum = VARNUM(dsid, "LEVEL");
106232    +          if levelnum then do;
106233    +            if ^fetch(dsid) then
106234    +              call symput('TARGET_EVENT',   strip(getvarc(dsid, levelnum)));
106236    +            if ^fetch(dsid) then
106237    +              call symput('TARGET_NONEVENT',strip(getvarc(dsid, levelnum)));
106238    +          end;
106239    +          dsid=close(dsid);
106240    +          end;
106241    +        run;
106242    +        proc datasets library=work nolist;
106243    +           delete eventout;
106244    +        run;
106245    +        quit;
106246    +      %end;
106247    +      %else %do;
106248    +         %let dsid=%sysfunc(open(&EM_DEC_DECMETA(where=(_TYPE_='TARGET'))));
106250    +         %let vn_event =%sysfunc(varnum(&dsid, EVENT));
106251    +         %let vn_target_type = %sysfunc(varnum(&dsid, TYPE));
106252    +         %let vn_target_format = %sysfunc(varnum(&dsid, FORMAT));
106254    +         %do %while(^ %sysfunc(fetch(&dsid)));
106255    +            %let Target_Event = %sysfunc(getvarc(&dsid, &vn_event));
106256    +            %let Target_Type =  %sysfunc(getvarc(&dsid, &vn_target_type));
106257    +            %let Target_Format = %sysfunc(getvarc(&dsid, &vn_target_format));
106258    +         %end;
106259    +         %let dsid = %sysfunc(close(&dsid));
106261    +         %let dsid=%sysfunc(open(&EM_DEC_DECDATA));
106262    +           %let obs = %sysfunc(fetchobs(&dsid, 2));
106263    +           %let vn_nonevent = %sysfunc(varnum(&dsid, %EM_BINARY_TARGET));
106264    +           %let Target_NonEvent= %sysfunc(getvarc(&dsid, &vn_nonevent));
106265    +         %let dsid = %sysfunc(close(&dsid));
106266    +      %end;
106268    +      %global ignbintarget;
106269    +      %let ignbintarget = %EM_BINARY_TARGET;
106271    +      data &EM_USER_NEWTRAIN;
106272    +        set &EM_IMPORT_DATA;
106273    +      run;
106274    +   %end;
106275    +   %else %do; /* preprocessing for interval target */
106276    +      %if &EM_PROPERTY_INTTARGETMETHOD=CUTUSER %then %do;
106277    +         proc dmdb data=&EM_IMPORT_DATA varout=minmax;
106278    +            var &target_var;
106279    +         run;
106281    +         data _null_;
106282    +            set minmax;
106283    +            call symput('tarmax',strip(max));
106284    +            call symput('tarmin',strip(min));
106285    +         run;
106287    +         /* cutoff can equal tarmin but not tarmax */
106288    +         %if %sysevalf(&EM_PROPERTY_USERCUTVALUE >= &tarmax) or
106288   !+%sysevalf(&EM_PROPERTY_USERCUTVALUE < &tarmin) %then %do;
106289    +            %let EMEXCEPTIONSTRING =
106289   !+exception.server.IGN.CUTOFFOUTOFRANGE,&tarmin,&tarmax;
106290    +            %put &em_codebar;
106291    +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, cutoffoutofrange_error,
106291   !+NOQUOTE, &tarmin, &tarmax));
106292    +            %put &errormsg;
106293    +            %put &em_codebar;
106294    +            %goto doendm;
106295    +         %end;
106296    +      %end;
106298    +      %global ignbintarget;
106299    +      %getVarName(&EM_IMPORT_DATA,
106299   !+BIN_%substr(%EM_INTERVAL_TARGET,1,%sysfunc(min(%length(%EM_INTERVAL_TARGET),28))),
106299   !+IGNBinTarget);
106301    +      %EM_IBN_IntTargetTrans(%EM_INTERVAL_TARGET,&EM_PROPERTY_INTTARGETMETHOD,newLev
106301   !+els=igntbinlevs);
106302    +      %if &igntbinlevs ne 2 %then %do;
106303    +         %let EMEXCEPTIONSTRING = exception.server.IGN.NONBINTARGETTRANS;
106304    +         %put &em_codebar;
106305    +         %let errormsg = %sysfunc(sasmsg(sashelp.dmine, nonbintargettrans_error,
106305   !+NOQUOTE));
106306    +         %put &errormsg;
106307    +         %put &em_codebar;
106308    +         %goto doendm;
106309    +      %end;
106311    +      %let Target_Event = 1;
106312    +      %let Target_NonEvent = 0;
106313    +      %let Target_Type = BINARY;
106314    +      %let Target_Format = ;
106316    +   %end;
106318    +   /* data sets */
106319    +   %EM_GETNAME(key=BINDATA,        type=DATA);
106320    +   %EM_GETNAME(key=SPLITVALS,      type=DATA);
106321    +   %EM_GETNAME(key=VARMAPPINGS,    type=DATA);
106322    +   %EM_GETNAME(key=BINMAPPINGS,    type=DATA);
106323    +   %EM_GETNAME(key=COARSE,          type=DATA);
106324    +   %EM_GETNAME(key=FINEDETAILDATA, type=DATA);
106325    +   %EM_GETNAME(key=RESULTSTABLE,   type=DATA);
106327    +   /* files */
106328    +   %EM_GETNAME(key=BINNINGCODE, type=FILE, extension=sas);
106329    +   %EM_GETNAME(key=GROUPMAPPINGSCORECODE, type=FILE, extension=sas);
106331    +   /* if freeze eq Y and no finedetaildata exists, throw an exception */
106332    +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
106333    +     %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) ne 1 %then %do;
106334    +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOFINEDETAIL;
106335    +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, nofinedetail_error , NOQUOTE))
106335   !+;
106337    +        %put &em_codebar;
106338    +        %put &errmsg;
106339    +        %put &em_codebar;
106340    +        %goto doendm;
106341    +     %end;
106342    +   %end;
106344    +   %global useImport;
106345    +   %let useImport = 0;
106347    +   %EM_GETNAME(key=IMPORTSUBSET, type=DATA);
106349    +   %if %sysfunc(exist(&EM_USER_IMPORTSUBSET, DATA)) %then %do;
106350    +     proc datasets library=&EM_LIB nolist;
106351    +       delete &EM_NODEID._IMPORTSUBSET;
106352    +     run;
106353    +     quit;
106354    +   %end;
106356    +   /* if importGrouping=Y, verify that data and all vars exist and are of the
106356   !+correct type */
106357    +   %if &EM_PROPERTY_IMPORTGROUPING eq Y %then %do;
106359    +     /* if import eq Y and no importtable exists, throw an exception */
106360    +     %if %sysfunc(exist(&EM_PROPERTY_IMPORTDATA, DATA)) ne 1 %then %do;
106361    +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOIMPORT;
106362    +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, noimport_error , NOQUOTE));
106364    +        %put &em_codebar;
106365    +        %put &errmsg;
106366    +        %put &em_codebar;
106367    +        %goto doendm;
106368    +     %end;
106370    +      %let dsid = %sysfunc(open(&EM_PROPERTY_IMPORTDATA));
106371    +      %if &dsid %then %do;
106372    +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
106373    +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
106374    +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
106375    +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
106377    +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
106378    +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
106379    +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
106380    +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
106381    +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
106382    +         %end;
106383    +      %end;
106384    +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106386    +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
106387    +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C))
106387   !+%then %do;
106389    +        /* generate subset of data that contains those vars also found in training
106389   !+data and add display_var information */
106390    +        proc sort data=&EM_PROPERTY_IMPORTDATA out=tempimport;
106391    +           by _VARIABLE_ ;
106392    +        run;
106394    +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME
106394   !+rename=(NAME=_VARIABLE_));
106395    +          by NAME;
106396    +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y')
106396   !+;
106397    +        run;
106399    +        data &EM_USER_IMPORTSUBSET;
106400    +          merge tempimport(in=_a) tempvarset(in=_b);
106401    +          length display_Var $32;
106402    +          by _VARIABLE_;
106403    +          display_var = _Variable_;
106404    +          if _a and _b then output;
106405    +        run;
106407    +        proc datasets library=work nolist;
106408    +          delete tempimport tempvarset;
106409    +        run;
106410    +        quit;
106412    +        %end;
106413    +      %end;
106414    +   %end;
106416    +   /* set useImport flag if there are obs in the importSubset dataset */
106417    +   %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET));
106418    +   %if &dsid %then %do;
106419    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
106420    +     %if &nobs gt 0 %then %let useimport = 1;
106421    +   %end;
106422    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106424    +   %global useFreeze;
106425    +   %let useFreeze = 0;
106427    +   /* if Freeze=Y, verify that data and all vars exist and are of the correct type
106427   !+*/
106428    +   %EM_GETNAME(key=FREEZESUBSET, type=DATA);
106430    +   %if %sysfunc(exist(&EM_USER_FREEZESUBSET, DATA)) %then %do;
106431    +     proc datasets library=&EM_LIB nolist;
106432    +       delete &EM_NODEID._FREEZESUBSET;
106433    +     run;
106434    +     quit;
106435    +   %end;
106437    +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
106439    +      /* create freezesubset data to contain information on pre-binned data and raw
106439   !+values */
106440    +      %EM_GENERATE_EXPORTGROUP(&EM_USER_FREEZESUBSET, OVERWRITE);
106442    +      %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
106443    +      %if &dsid %then %do;
106444    +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
106445    +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
106446    +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
106447    +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
106449    +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
106450    +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
106451    +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
106452    +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
106453    +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
106454    +         %end;
106455    +      %end;
106456    +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106458    +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
106459    +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C))
106459   !+%then %do;
106461    +        /* generate subset of data that contains those vars also found in training
106461   !+data */
106462    +        proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze;
106463    +           by _VARIABLE_ ;
106464    +        run;
106466    +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME
106466   !+rename=(NAME=_VARIABLE_));
106467    +          by NAME;
106468    +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y')
106468   !+;
106469    +        run;
106471    +        data &EM_USER_FREEZESUBSET;
106472    +          merge tempfreeze(in=_a) tempvarset(in=_b);
106473    +          length display_Var $32;
106474    +          by _VARIABLE_;
106475    +          display_var = _Variable_;
106476    +          if _a and _b then output;
106477    +        run;
106479    +        proc datasets library=work nolist;
106480    +          delete tempfreeze tempvarset;
106481    +        run;
106482    +        quit;
106483    +        %end;
106484    +      %end;
106485    +   %end;
106487    +   /* set useFreeze flag if there are obs in the freezeSubset dataset */
106488    +   %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
106489    +   %if &dsid %then %do;
106490    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
106491    +     %if &nobs gt 0 %then %let useFreeze = 1;
106492    +   %end;
106493    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106495    +   /* if finedetail already exists, delete prior to re-run */
106496    +   %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) %then %do;
106497    +     proc datasets library=&EM_LIB nolist;
106498    +       delete &EM_NODEID._FINEDETAILDATA;
106499    +     run;
106500    +     quit;
106501    +   %end;
106503    +   data tempvarnames;
106504    +     set &EM_DATA_VARIABLESET;
106505    +     where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y'))
106505   !+and level ne 'UNARY';
106506    +     keep NAME LEVEL LABEL;
106507    +   run;
106509    +   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
106510    +     names NAME;
106511    +     prefix WOE_ GRP_ ;
106512    +   run;
106514    +   proc sort data=tempmapping; by name; run;
106515    +   proc sort data=tempvarnames; by name; run;
106516    +   data tempmapping;
106517    +     merge tempmapping tempvarnames;
106518    +     by NAME;
106519    +     rename LEVEL=procLevel;
106520    +   run;
106522    +   /* generate initial columns of mapping table by setting grpflag=0 */
106523    +   %EM_GENERATE_MAPPING_TABLE;
106525    +   proc datasets library=work nolist;
106526    +     delete tempImport tempScore;
106527    +   run;
106528    +   quit;
106530    +   /* delete splitvals dataset if this existed prior to run */
106531    +   %let nvars=0;
106532    +   %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
106533    +   %if &sdsid > 0 %then %do;
106534    +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
106535    +   %end;
106536    +   %if &sdsid > 0 %then  %let sdsid=%sysfunc(close(&sdsid));
106538    +   %if &nvars > 0 %then %do;
106539    +      proc datasets library=&EM_LIB nolist;
106540    +        delete &EM_NODEID._SPLITVALS;
106541    +      run;
106542    +      quit;
106543    +   %end;
106545    +   %global classvars qclassvars;
106546    +   %let classvars=;
106547    +   %let qclassvars=;
106549    +   /* generate the intervalvars and classvars macros */
106550    +   %EM_PRE_BINNING(&EM_USER_NEWTRAIN);
106552    +   /* update varmappings with any changes to procLevel based on discretemid */
106553    +   data &EM_USER_VARMAPPINGS;
106554    +     set &EM_USER_VARMAPPINGS;
106555    +     /* procLevel column to indicate the level used by proc; this handles*/
106556    +     /* cases in which var is marked INTERVAL in metadat but treated as  */
106557    +     /* ordinal in prebinning because of # unique levels                 */
106558    +     %let dsid = %sysfunc(open(work._discretemid));
106559    +     %if &dsid %then %do;
106560    +       %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
106561    +       %let obs = %sysfunc(fetch(&dsid));
106562    +       %do %while(&obs=0);
106563    +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
106564    +          if _variable_ = "&varname" then procLevel = "ORDINAL";
106565    +          %let obs = %sysfunc(fetch(&dsid));
106566    +       %end;
106567    +     %end;
106568    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106569    +     label procLevel =  "%sysfunc(sasmsg(sashelp.dmine, rpt_proclevel_vlabel ,
106569   !+NOQUOTE))";
106570    +   run;
106572    +   /* generate Grp_xxx variables for interval inputs */
106573    +   %if &EM_PROPERTY_BINMETHOD eq QUANTILE %then %do;
106574    +     %EM_QUANTILE_BINNING(&EM_USER_NEWTRAIN, WORK.PCTILE, &EM_USER_BINDATA,
106574   !+&EM_USER_BINNINGCODE);
106576    +   %end;
106577    +   %else %do;
106578    +     %EM_EQUAL_SPACED_BINNING(&EM_USER_NEWTRAIN, &EM_USER_BINDATA,
106578   !+&EM_USER_BINNINGCODE);
106579    +   %end;
106581    +   /* generate GRP_XXX variables for nominal inputs */
106582    +   %EM_CLASSVARS_GROUP(&EM_PROPERTY_CLASSGROUPRARE);
106584    +   /* generate GRP_XXX variables for ordinal inputs */
106585    +   %EM_ORDVARS_GROUP;
106587    +   proc print data=&EM_USER_VARMAPPINGS label;
106588    +     var _VARIABLE_ _GRP_VARIABLE_ ;
106589    +   run;
106591    +   /* add _proc_var_ to varmappings data to know names of processed variables; could
106591   !+ be original input, could be bin_xxx */
106592    +   proc sort data=&EM_USER_SPLITVALS out=tempsplitvals nodupkey;
106593    +     by _VARIABLE_;
106594    +   run;
106596    +   data &EM_USER_VARMAPPINGS;
106597    +     set &EM_USER_VARMAPPINGS;
106598    +     length _proc_var_ $32;
106599    +     %let dsid = %sysfunc(open(work.tempsplitvals));
106600    +     %if &dsid %then %do;
106601    +        %let obs = %sysfunc(fetch(&dsid));
106602    +        %do %while(&obs=0);
106603    +          %let dispnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
106604    +          %let dispvar = %sysfunc(getvarc(&dsid, &dispnum));
106605    +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
106606    +          %let var = %sysfunc(getvarc(&dsid, &varnum));
106608    +          if upcase(_VARIABLE_) = %upcase("&dispvar") then _proc_var_ = "&var";
106609    +          %let obs = %sysfunc(fetch(&dsid));
106610    +        %end;
106611    +     %end;
106612    +     if missing(_proc_var_) then _proc_var_=_variable_;
106613    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106614    +   run;
106616    +   proc datasets library=work nolist;
106617    +     delete sortedbin tempsplitvals;
106618    +   run;
106619    +   quit;
106621    +   /* calculate Fine Detail statistics for each input */
106622    +   %EM_FINE_DETAIL(&EM_USER_BINDATA, &EM_USER_VARMAPPINGS, &EM_USER_FINEDETAILDATA,
106622   !+&EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS);
106624    +   /* apply grouping and create grouped dataset */
106625    +   %EM_CREATE_GROUPING(&EM_USER_BINDATA, &EM_USER_FINEDETAILDATA, &EM_USER_COARSE);
106627    +   /* generate _label_ values in the COARSE dataset from the Scored data */
106628    +   filename Y "&EM_USER_GROUPMAPPINGSCORECODE";
106629    +   %EM_GENERATE_LABELVALUES(Y, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS,
106629   !+&EM_USER_COARSE);
106630    +   filename Y;
106632    +   /* set EM_MODEL ASSESS=N to prevent assessment reports from being generated */
106633    +   %EM_MODEL(Target= &ignbintarget, ASSESS=N);
106635    +   /* generate reports */
106636    +   %EM_REPORT(key=COARSE, viewtype=DATA, block=MODEL, description=EVENTRATESTAT,
106636   !+autodisplay=N, spk=N);
106639    +   %doendm:
106640    +%mend train;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(TRAIN):   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
NOTE: %INCLUDE (level 1) file TRTEMP is file SASHELP.EMMDFY.BINNING_TRAINMACROS.SOURCE.
106642    +%macro EM_GENERATE_MAPPING_TABLE;
106644    +  %EM_GETNAME(key=VARMAPPINGS, type=DATA);
106645    +  data &EM_USER_VARMAPPINGS(keep=_variable_  _grp_variable_ procLevel label);
106646    +   length _variable_  _grp_variable_  $32 procLevel $8;
106647    +   set tempmapping;
106648    +   label _variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_inputvar_vlabel ,
106648   !+NOQUOTE))"
106649    +         _grp_variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_grpvar_vlabel ,
106649   !+NOQUOTE))";
106651    +         _variable_ = NAME;
106652    +         _grp_variable_ = GRP;
106653    + run;
106655    +%mend EM_GENERATE_MAPPING_TABLE;
106657    +%macro EM_PRE_BINNING(input);
106658    +    /* Determine which of our variables are interval  */
106660    +    data tempvariableset;
106661    +      set &EM_DATA_VARIABLESET;
106662    +      where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR
106662   !+(ROLE='REJECTED' and USE='Y'));
106663    +    run;
106665    +    /* add all interval vars to the intervalvar macro
106666    +    %let dsid = %sysfunc(open(work.tempvariableset));
106667    +    %if &dsid %then %do;
106668    +       %let varnum = %sysfunc(VARNUM(&dsid, NAME));
106669    +       %let obs = %sysfunc(fetch(&dsid));
106670    +       %do %while(&obs=0);
106671    +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
106672    +          %let intervalvars = &intervalvars &varname;
106673    +          %let obs = %sysfunc(fetch(&dsid));
106674    +       %end;
106675    +    %end;
106676    +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106677    + */
106679    +   %em_varmacro(name=intervalvars, metadata=tempvariableset, key=NAME,
106679   !+nummacro=num_intvars);
106681    +    /* Determine which variables marked as interval are true interval distributions;
106681   !+ */
106682    +    /* intmid contains variables that are actually interval and should be binned; */
106683    +    /* discretemid contains variables that are actually discrete and should NOT be
106683   !+binned */
106684    +    %if %intervalvars ne %then %do;
106685    +      %let _maxlevel = %eval(&EM_PROPERTY_NUMBINS + 1);
106686    +      proc dmdb data=&input classout=_CLASSOUT maxlevel=&_maxlevel;
106687    +        class %intervalvars;
106688    +      run;
106689    +      proc freq data=_CLASSOUT order=DATA noprint;
106690    +         table NAME / OUT= _COUNT(where=(COUNT<&_maxlevel));
106691    +      run;
106693    +      %let _INTBINS=;
106694    +      data _null_;
106695    +        set _COUNT;
106696    +        call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
106697    +      run;
106699    +      proc sort data=_CLASSOUT;
106700    +        by NAME;
106701    +      run;
106702    +      proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE))
106702   !+prefix=_MIDPOINT;
106703    +        var NRAW;
106704    +        by NAME;
106705    +      run;
106707    +      data _null_;
106708    +        dsid = open('_OUT');
106709    +        if dsid then do;
106710    +           call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1,
106710   !+best12.))));
106711    +           csid = close(dsid);
106712    +        end;
106713    +      run;
106714    +      data _INTMID;
106715    +        set _OUT;
106716    +        keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
106717    +        %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
106718    +          if ^indexw("&_INTBINS", VARIABLE) then output;
106719    +        %end;
106720    +      run;
106722    +      %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
106723    +        data _DISCRETEMID;
106724    +          set _OUT;
106725    +          keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
106726    +          if indexw("&_INTBINS", VARIABLE) then output;
106727    +        run;
106728    +      %end;
106729    +      %else %do;
106730    +         %if %sysfunc(exist(_discretemid)) %then %do;
106731    +            proc delete data=_discretemid;
106732    +            run;
106733    +         %end;
106734    +      %end;
106736    +      /* add vars from the _DISCRETEMID dataset to the classvars macro
106737    +      %let dsid = %sysfunc(open(WORK._DISCRETEMID));
106738    +      %if &dsid %then %do;
106739    +        %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
106740    +        %let obs = %sysfunc(fetch(&dsid));
106742    +        %do %while(&obs=0);
106743    +          %let var = %sysfunc(getvarc(&dsid, &varnum));
106744    +          %let classvars = &classvars &var;
106745    +          %let qclassvars = &qclassvars "&var";
106746    +          %let obs = %sysfunc(fetch(&dsid));
106747    +        %end;
106748    +      %end;
106749    +      %if &dsid  %then %let dsid = %sysfunc(close(&dsid));
106750    +*/
106751    +    %end;
106752    +    %else %do;
106753    +      %if %sysfunc(exist(_intmid)) %then %do;
106754    +         proc delete data=_intmid;
106755    +         run;
106756    +      %end;
106758    +      %if %sysfunc(exist(_discretemid)) %then %do;
106759    +         proc delete data=_discretemid;
106760    +         run;
106761    +      %end;
106762    +    %end;
106764    +    /* if import grouping then remove interval vars in import data from _INTMID */
106765    +    %if &useImport eq 1 %then %do;
106767    +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
106768    +        by _VARIABLE_;
106769    +      run;
106771    +      data &EM_USER_IMPORTSUBSET;
106772    +        length CODEVAR $32;
106773    +        set &EM_USER_IMPORTSUBSET;
106774    +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
106775    +      run;
106777    +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
106778    +        by _VARIABLE_;
106779    +      run;
106781    +      %let dsid = %sysfunc(open(work.tempsubset));
106782    +      %let nobs = 0;
106783    +      %if &dsid %then %do;
106784    +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
106785    +      %end;
106786    +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
106788    +      data tempsubset;
106789    +        set tempsubset;
106790    +        length  binVar suffix $32;
106791    +        array binnames{&nobs} $32 _temporary_;
106792    +        retain binVar binnames;
106793    +        by _VARIABLE_;
106795    +        binVar = 'BIN_'!!strip(CODEVAR);
106796    +        binVar = ksubstr(binVar, 1, 32);
106797    +        count = 1;
106799    +        do i=1 to _N_;
106800    +           do while(binvar eq binnames(i));
106801    +              suffix = strip(put(count,best.));
106802    +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
106803    +              count + 1;
106804    +           end;
106805    +        end;
106806    +        binnames(_N_)= binvar;
106807    +        output;
106808    +        drop suffix count i;
106809    +     run;
106811    +     data &EM_USER_IMPORTSUBSET;
106812    +       set &EM_USER_IMPORTSUBSET;
106813    +       length binVar $32;
106815    +        %let dsid = %sysfunc(open(work.tempsubset));
106816    +        %if &dsid %then %do;
106817    +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
106818    +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
106819    +          %let obs = %sysfunc(fetch(&dsid));
106821    +          %do %while(&obs=0);
106822    +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
106823    +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
106825    +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
106826    +            %let obs = %sysfunc(fetch(&dsid));
106827    +          %end;
106828    +        %end;
106829    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106830    +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
106831    +        if binVar ne "" then do;
106832    +          _LEVEL_ = "ORDINAL";
106833    +        end;
106835    +      run;
106837    +      %let idsidexists=0;
106838    +      %let idsid = %sysfunc(open(work._intmid));
106839    +      %if &idsid %then %do;
106840    +        %let idsidexists=1;
106841    +        %let idsid = %sysfunc(close(&idsid));
106842    +      %end;
106844    +      %if &idsidexists = 1 %then %do;
106845    +      data _INTMID;
106846    +        set _INTMID;
106848    +        %let dsid = %sysfunc(open(work.tempsubset));
106849    +        %if &dsid %then %do;
106850    +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
106851    +          %let obs = %sysfunc(fetch(&dsid));
106853    +          %do %while(&obs=0);
106854    +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
106855    +            if variable = "&codevar" then delete;
106856    +            %let obs = %sysfunc(fetch(&dsid));
106857    +          %end;
106858    +        %end;
106859    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106860    +      run;
106861    +      %end;
106863    +      proc datasets library=work nolist;
106864    +        delete tempsubset;
106865    +      run;
106866    +      quit;
106867    +    %end;
106869    +    /* if freeze then remove interval vars in import data from _INTMID */
106870    +    %if &useFreeze eq 1 %then %do;
106872    +      data &EM_USER_FREEZESUBSET;
106873    +        length CODEVAR $32;
106874    +        set &EM_USER_FREEZESUBSET;
106875    +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
106876    +      run;
106878    +      proc sort data=&EM_USER_FREEZESUBSET out=tempsubset nodupkey;
106879    +        by _VARIABLE_;
106880    +      run;
106882    +      %let dsid = %sysfunc(open(work.tempsubset));
106883    +      %let nobs = 0;
106884    +      %if &dsid %then %do;
106885    +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
106886    +      %end;
106887    +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
106889    +      data tempsubset;
106890    +        set tempsubset;
106891    +        length  binVar suffix $32;
106892    +        array binnames{&nobs} $32 _temporary_;
106893    +        retain binVar binnames;
106894    +        by _VARIABLE_;
106896    +        binVar = 'BIN_'!!strip(CODEVAR);
106897    +        binVar = ksubstr(binVar, 1, 32);
106898    +        count = 1;
106900    +        do i=1 to _N_;
106901    +           do while(binvar eq binnames(i));
106902    +              suffix = strip(put(count,best.));
106903    +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
106904    +              count + 1;
106905    +           end;
106906    +        end;
106907    +        binnames(_N_)= binvar;
106908    +        output;
106909    +        drop suffix count i;
106910    +     run;
106912    +     data &EM_USER_FREEZESUBSET;
106913    +       set &EM_USER_FREEZESUBSET;
106914    +       length binVar $32;
106916    +        %let dsid = %sysfunc(open(work.tempsubset));
106917    +        %if &dsid %then %do;
106918    +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
106919    +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
106920    +          %let obs = %sysfunc(fetch(&dsid));
106922    +          %do %while(&obs=0);
106923    +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
106924    +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
106926    +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
106927    +            %let obs = %sysfunc(fetch(&dsid));
106928    +          %end;
106929    +        %end;
106930    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106932    +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
106933    +        if binVar ne "" then do;
106934    +          _LEVEL_ = "ORDINAL";
106935    +        end;
106937    +      run;
106939    +      %let idsidexists= 0;
106940    +      %let idsid = %sysfunc(open(work._intmid));
106941    +      %if &idsid %then %do;
106942    +        %let idsidexists=1;
106943    +        %let idsid = %sysfunc(close(&idsid));
106944    +      %end;
106945    +      %if &idsidexists eq 1 %then %do;
106946    +      data _INTMID;
106947    +        set _INTMID;
106949    +        %let dsid = %sysfunc(open(work.tempsubset));
106950    +        %if &dsid %then %do;
106951    +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
106952    +          %let obs = %sysfunc(fetch(&dsid));
106954    +          %do %while(&obs=0);
106955    +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
106956    +            if variable = "&codevar" then delete;
106957    +            %let obs = %sysfunc(fetch(&dsid));
106958    +          %end;
106959    +        %end;
106960    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106961    +      run;
106962    +      %end;
106964    +      proc datasets library=work nolist;
106965    +        delete tempsubset;
106966    +      run;
106967    +      quit;
106969    +    %end;
106971    +%mend EM_PRE_BINNING;
106973    +%macro EM_IMPORT_BINNING(binningCode);
106976    +   data tempintimport;
106977    +     set &EM_USER_IMPORTSUBSET;
106978    +     if binflag = 1;
106979    +   run;
106981    +   %let idsid = %sysfunc(open(work.tempintimport));
106982    +   %if &idsid %then %do;
106983    +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
106984    +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
106985    +   %end;
106986    +   %else %do;
106987    +     %let nvars = 0;
106988    +     %let nobs = 0;
106989    +   %end;
106990    +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
106992    +   proc datasets library=work nolist;
106993    +     delete tempintimport;
106994    +   run;
106995    +   quit;
106997    +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
106999    +      filename X "&binningCode";
107000    +      data _null_;
107001    +        FILE X MOD;
107002    +        %let bin_variables=;
107003    +        %let quote_bin_variables = ;
107004    +        %let choice = binflag = 1;
107005    +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
107006    +        %if &dsid %then %do;
107007    +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
107008    +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
107009    +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
107010    +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingbins_note ,
107010   !+NOQUOTE));
107012    +           put "&EM_CODEBAR;";
107013    +           put " &note; ";
107014    +           put "&EM_CODEBAR;";
107016    +           /* retrieve value for first obs */
107017    +           %let obs = %sysfunc(fetchobs(&dsid, 1));
107018    +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
107019    +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
107021    +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
107022    +           %let i = 1;
107023    +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0
107023   !+%then %do;
107024    +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
107025    +           %end;
107026    +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
107027    +           put " ";
107028    +           put "if &oldname eq . then &binvalue = .;";
107030    +           /* cycle through special codes if they exist */
107031    +           %let index2 = %index(&oldname, SV_);
107032    +           %if &index2 gt 0 %then %do;
107033    +             %let choice = CODEVAR ="&oldname";
107034    +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
107035    +             %if &cdsid %then %do;
107036    +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
107037    +                %let cobs = %sysfunc(fetch(&cdsid));
107038    +                %do %while(&cobs=0);
107039    +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
107040    +                    put "else if &oldname eq &code then &binvalue = &code;";
107041    +                   %let cobs = %sysfunc(fetch(&cdsid));
107042    +                %end;
107043    +             %end;
107044    +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
107045    +           %end;
107046    +           put "else ";
107047    +           %if "&value" eq "." %then %do;
107048    +             put " &binvalue=&i;";
107049    +           %end;
107050    +           %else %do;
107051    +             put "  if &oldname < &value then &binvalue=&i;";
107052    +           %end;
107054    +           %let i= %eval(&i+1);
107056    +           %let obs = %sysfunc(fetch(&dsid));
107057    +           %do %while(&obs=0);
107058    +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
107059    +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
107060    +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
107062    +              %if "&oldname" ne "&namevalue" %then %do;
107064    +                /* if variable has been re-coded for special codes, must include
107064   !+these values as well */
107065    +                put;
107066    +                put "if &namevalue eq . then &binvalue = .;";
107068    +                %let i=1;
107069    +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq
107069   !+ 0 %then %do;
107070    +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
107071    +                %end;
107072    +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
107074    +                /* cycle through special codes if they exist */
107075    +                %let index2 = %index(&namevalue, SV_);
107076    +                %if &index2 gt 0 %then %do;
107077    +                  %let choice = CODEVAR ="&namevalue";
107078    +                  %let cdsid =
107078   !+%sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
107079    +                  %if &cdsid %then %do;
107080    +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
107081    +                     %let cobs = %sysfunc(fetch(&cdsid));
107082    +                     %do %while(&cobs=0);
107083    +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
107084    +                       put "else if &namevalue eq &code then &binvalue = &code;";
107085    +                       %let cobs = %sysfunc(fetch(&cdsid));
107086    +                     %end;
107087    +                  %end;
107088    +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
107089    +                %end;
107090    +                put "else ";
107091    +                %if "&value" ne "." %then %do;
107092    +                  put "  if &namevalue < &value then &binvalue=&i;";
107093    +                %end;
107094    +                %else %do;
107095    +                  put " &binvalue=&i;";
107096    +                %end;
107098    +              %end;
107099    +              %else %do;
107100    +                put "else ";
107101    +                %if "&value" ne "." %then %do;
107102    +                  put "  if &namevalue < &value then &binvalue=&i;";
107103    +                %end;
107104    +                %else %do;
107105    +                  put "  &binvalue=&i;";
107106    +                %end;
107107    +              %end;
107108    +              %let i = %eval(&i + 1);
107109    +              %let obs = %sysfunc(fetch(&dsid));
107110    +              %let oldname = &namevalue;
107111    +              %let oldbinvalue = &binvalue;
107112    +           %end;
107113    +        %end;
107114    +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
107116    +      run;
107117    +      filename X;
107118    +      /* generate BINMAPPINGS dataset */
107119    +      data TEMPBINMAPPINGS;
107120    +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var
107120   !+grp_name $32;
107122    +        %let choice = binflag = 1;
107123    +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
107124    +        %if &dsid %then %do;
107125    +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
107126    +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
107127    +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
107128    +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
107129    +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
107131    +           /* retrieve information from first obs */
107132    +           %let obs = %sysfunc(fetchobs(&dsid, 1));
107133    +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
107134    +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
107135    +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
107136    +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar,5));
107137    +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
107138    +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
107139    +           %let i = 1;
107141    +           NAME = "&OLDCODEVAR";
107142    +           BIN_NAME = "&OLDBINVAR";
107143    +           GRP_NAME = "&OLDGRPVAR";
107144    +           BIN = "&i";
107145    +           GRP = "&oldgrpvalue";
107146    +           LB = . ;
107147    +           UB = &oldvalue;
107148    +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
107149    +           DISPLAY_VAR = "&oldvar";
107150    +           output;
107152    +           %let i = 2;
107153    +           %let obs = %sysfunc(fetch(&dsid));
107154    +           %do %while(&obs=0);
107155    +             %let var = %sysfunc(getvarc(&dsid, &varnum));
107156    +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
107157    +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
107158    +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar,5));
107159    +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
107160    +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
107162    +             %if "&oldvar" ne "&var" %then %do;
107163    +              %let i = 1;
107164    +               %let oldvalue = .;
107165    +             %end;
107167    +             NAME = "&CODEVAR";
107168    +             BIN_NAME = "&BINVAR";
107169    +             GRP_NAME = "&GRPVAR";
107170    +             BIN = "&i";
107171    +             GRP = "&group";
107172    +             LB = &oldvalue ;
107173    +             UB = &value;
107174    +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
107175    +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
107176    +             %end;
107177    +             %else %do;
107178    +               %if "&oldvalue" eq "." %then %do;
107179    +                 EM_BIN_LABEL = "&var < &value" ;
107180    +               %end;
107181    +               %if "&value" eq "." %then %do;
107182    +                 EM_BIN_LABEL = "&oldvalue >= &var";
107183    +               %end;
107184    +             %end;
107185    +             DISPLAY_VAR = "&var";
107186    +             output;
107188    +             %let oldvar = &var;
107189    +             %let oldcodevar = &codevar;
107190    +             %let oldbinvar = &binvar;
107191    +             %let oldgrpvar = &grpvar;
107192    +             %let oldvalue   = &value;
107193    +             %let oldgrpvalue   = &group;
107194    +             %let i = %eval(&i + 1);
107195    +             %let obs = %sysfunc(fetch(&dsid));
107196    +           %end;
107197    +        %end;
107198    +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
107199    +      run;
107201    +      data &EM_USER_BINMAPPINGS;
107202    +        set &EM_USER_BINMAPPINGS tempBinMappings;
107203    +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
107204    +      run;
107206    +      /* update importsubset with bin values instead of raw values */
107207    +      data &EM_USER_IMPORTSUBSET;
107208    +        set &EM_USER_IMPORTSUBSET;
107210    +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
107211    +        %if &dsid %then %do;
107212    +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
107213    +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
107214    +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
107215    +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
107216    +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
107217    +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
107219    +          %let oldvar = ;
107220    +          %let obs = %sysfunc(fetch(&dsid));
107221    +          %do %while(&obs=0);
107222    +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
107223    +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
107224    +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
107225    +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
107226    +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
107227    +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
107229    +            %if "&oldvar" eq "&displayvar" %then %do;
107230    +              else
107231    +            %end;
107232    +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
107233    +               _SPLIT_VALUE_ = "&bin";
107234    +            end;
107235    +            %let oldvar = &displayvar;
107236    +            %let obs = %sysfunc(fetch(&dsid));
107237    +          %end;
107238    +        %end;
107239    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
107240    +      run;
107242    +      proc sort data=&EM_USER_IMPORTSUBSET;
107243    +        by _VARIABLE_ _SPLIT_VALUE_;
107244    +      run;
107246    +      proc datasets library=work nolist;
107247    +        delete tempBinMappings;
107248    +      run;
107249    +      quit;
107250    +  %end;
107251    +%mend EM_IMPORT_BINNING;
107253    +%macro EM_FREEZE_BINNING(binningCode);
107255    +   data tempintfreeze;
107256    +     set &EM_USER_FREEZESUBSET;
107257    +     if binflag = 1;
107258    +   run;
107260    +   %let idsid = %sysfunc(open(work.tempintfreeze));
107261    +   %if &idsid %then %do;
107262    +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
107263    +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
107264    +   %end;
107265    +   %else %do;
107266    +     %let nvars = 0;
107267    +     %let nobs = 0;
107268    +   %end;
107269    +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
107271    +   proc datasets library=work nolist;
107272    +     delete tempintimport;
107273    +   run;
107274    +   quit;
107276    +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
107278    +      filename X "&binningCode";
107279    +      data _null_;
107280    +        FILE X MOD;
107282    +        %let bin_variables=.;
107283    +        %let quote_bin_variables=.;
107284    +        %let freeze_variables=;
107285    +        %let choice = binflag = 1;
107286    +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
107287    +        %if &dsid %then %do;
107288    +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
107289    +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
107290    +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
107291    +           %let vnum    = %sysfunc(VARNUM(&dsid, _variable_));
107293    +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingfrozenbins_note ,
107293   !+NOQUOTE));
107294    +           put "&EM_CODEBAR;";
107295    +           put "&note;";
107296    +           put "&EM_CODEBAR;";
107298    +           /* retrieve value for first obs */
107299    +           %let obs = %sysfunc(fetchobs(&dsid, 1));
107300    +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
107301    +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
107302    +           %let variable = %sysfunc(getvarc(&dsid, &vnum));
107304    +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
107305    +           %let i = 1;
107306    +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0
107306   !+%then %do;
107307    +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
107308    +           %end;
107309    +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
107310    +           %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
107312    +           put " ";
107313    +           put "if &oldname eq . then &binvalue = .;";
107315    +           /* cycle through special codes if they exist */
107316    +           %let index2 = %index(&oldname, SV_);
107317    +           %if &index2 gt 0 %then %do;
107318    +             %let choice = CODEVAR ="&oldname";
107319    +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
107320    +             %if &cdsid %then %do;
107321    +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
107322    +                %let cobs = %sysfunc(fetch(&cdsid));
107323    +                %do %while(&cobs=0);
107324    +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
107325    +                    put "else if &oldname eq &code then &binvalue = &code;";
107326    +                   %let cobs = %sysfunc(fetch(&cdsid));
107327    +                %end;
107328    +             %end;
107329    +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
107330    +           %end;
107331    +           put "else ";
107332    +           %if "&value" eq "." %then %do;
107333    +             put " &binvalue=&i;";
107334    +           %end;
107335    +           %else %do;
107336    +             put "  if &oldname < &value then &binvalue=&i;";
107337    +           %end;
107339    +           %let i= %eval(&i+1);
107341    +           %let obs = %sysfunc(fetch(&dsid));
107342    +           %do %while(&obs=0);
107343    +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
107344    +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
107345    +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
107346    +              %let variable = %sysfunc(getvarc(&dsid, &vnum));
107348    +              %if "&oldname" ne "&namevalue" %then %do;
107350    +                /* if variable has been re-coded for special codes, must include
107350   !+these values as well */
107351    +                put;
107352    +                put "if &namevalue eq . then &binvalue = .;";
107354    +                %let i=1;
107355    +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq
107355   !+ 0 %then %do;
107356    +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
107357    +                %end;
107358    +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
107359    +                %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
107361    +                /* cycle through special codes if they exist */
107362    +                %let index2 = %index(&namevalue, SV_);
107363    +                %if &index2 gt 0 %then %do;
107364    +                  %let choice = CODEVAR ="&namevalue";
107365    +                  %let cdsid =
107365   !+%sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
107366    +                  %if &cdsid %then %do;
107367    +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
107368    +                     %let cobs = %sysfunc(fetch(&cdsid));
107369    +                     %do %while(&cobs=0);
107370    +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
107371    +                       put "else if &namevalue eq &code then &binvalue = &code;";
107372    +                       %let cobs = %sysfunc(fetch(&cdsid));
107373    +                     %end;
107374    +                  %end;
107375    +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
107376    +                %end;
107377    +                put "else ";
107378    +                %if "&value" ne "." %then %do;
107379    +                  put "  if &namevalue < &value then &binvalue=&i;";
107380    +                %end;
107381    +                %else %do;
107382    +                  put " &binvalue=&i;";
107383    +                %end;
107385    +              %end;
107386    +              %else %do;
107387    +                put "else ";
107388    +                %if "&value" ne "." %then %do;
107389    +                  put "  if &namevalue < &value then &binvalue=&i;";
107390    +                %end;
107391    +                %else %do;
107392    +                  put " &binvalue=&i;";
107393    +                %end;
107394    +              %end;
107395    +              %let i = %eval(&i + 1);
107396    +              %let obs = %sysfunc(fetch(&dsid));
107397    +              %let oldname = &namevalue;
107398    +              %let oldbinvalue = &binvalue;
107399    +           %end;
107400    +        %end;
107401    +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
107403    +      run;
107404    +      filename X;
107405    +      /* generate BINMAPPINGS dataset */
107406    +      data TEMPBINMAPPINGS;
107407    +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var
107407   !+grp_name $32;
107409    +        %let choice = binflag = 1;
107410    +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
107411    +        %if &dsid %then %do;
107412    +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
107413    +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
107414    +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
107415    +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
107416    +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
107418    +           /* retrieve information from first obs */
107419    +           %let obs = %sysfunc(fetchobs(&dsid, 1));
107420    +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
107421    +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
107422    +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
107423    +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar, 5));
107424    +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
107425    +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
107426    +           %let i = 1;
107428    +           NAME = "&OLDCODEVAR";
107429    +           BIN_NAME = "&OLDBINVAR";
107430    +           GRP_NAME = "&OLDGRPVAR";
107431    +           BIN = "&i";
107432    +           GRP = "&oldgrpvalue";
107433    +           LB = . ;
107434    +           UB = &oldvalue;
107435    +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
107436    +           DISPLAY_VAR = "&oldvar";
107437    +           output;
107439    +           %let i = 2;
107440    +           %let obs = %sysfunc(fetch(&dsid));
107441    +           %do %while(&obs=0);
107442    +             %let var = %sysfunc(getvarc(&dsid, &varnum));
107443    +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
107444    +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
107445    +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar, 5));
107446    +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
107447    +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
107449    +             %if "&oldvar" ne "&var" %then %do;
107451    +               %let i = 1;
107452    +               %let oldvalue = .;
107453    +             %end;
107455    +             NAME = "&CODEVAR";
107456    +             BIN_NAME = "&BINVAR";
107457    +             GRP_NAME = "&GRPVAR";
107458    +             BIN = "&i";
107459    +             GRP = "&group";
107460    +             LB = &oldvalue ;
107461    +             UB = &value;
107462    +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
107463    +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
107464    +             %end;
107465    +             %else %do;
107466    +               %if "&oldvalue" eq "." %then %do;
107467    +                 EM_BIN_LABEL = "&var < &value" ;
107468    +               %end;
107469    +               %if "&value" eq "." %then %do;
107470    +                 EM_BIN_LABEL = "&oldvalue >= &var";
107471    +               %end;
107472    +             %end;
107473    +             DISPLAY_VAR = "&var";
107474    +             output;
107476    +             %let oldvar = &var;
107477    +             %let oldcodevar = &codevar;
107478    +             %let oldbinvar = &binvar;
107479    +             %let oldgrpvar = &grpvar;
107480    +             %let oldvalue   = &value;
107481    +             %let oldgrpvalue = &group;
107482    +             %let i = %eval(&i + 1);
107483    +             %let obs = %sysfunc(fetch(&dsid));
107484    +           %end;
107485    +        %end;
107487    +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
107488    +      run;
107490    +      /* remove obs from EM_USER_BINMAPPINGS that have vars also in tempBinMappings
107490   !+-- prevents duplicate entries */
107491    +      data &EM_USER_BINMAPPINGS;
107492    +        set &EM_USER_BINMAPPINGS;
107493    +        if NAME in (&FREEZE_VARIABLES) then delete;
107494    +      run;
107496    +      data &EM_USER_BINMAPPINGS;
107497    +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var
107497   !+grp_name $32;
107499    +        set &EM_USER_BINMAPPINGS tempBinMappings;
107500    +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
107501    +      run;
107503    +      /* update freezesubset with bin values instead of raw values */
107504    +      data &EM_USER_FREEZESUBSET;
107505    +        set &EM_USER_FREEZESUBSET;
107507    +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
107508    +        %if &dsid %then %do;
107509    +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
107510    +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
107511    +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
107512    +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
107513    +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
107514    +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
107516    +          %let oldvar = ;
107517    +          %let obs = %sysfunc(fetch(&dsid));
107518    +          %do %while(&obs=0);
107519    +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
107520    +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
107521    +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
107522    +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
107523    +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
107524    +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
107526    +            %if "&oldvar" eq "&displayvar" %then %do;
107527    +              else
107528    +            %end;
107529    +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
107530    +               _SPLIT_VALUE_ = "&bin";
107531    +            end;
107532    +            %let oldvar =&displayvar;
107533    +            %let obs = %sysfunc(fetch(&dsid));
107534    +          %end;
107535    +        %end;
107536    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
107537    +      run;
107539    +      proc sort data=&EM_USER_FREEZESUBSET;
107540    +        by _VARIABLE_ _SPLIT_VALUE_;
107541    +      run;
107543    +      proc datasets library=work nolist;
107544    +        delete tempBinMappings;
107545    +      run;
107546    +      quit;
107547    +   %end;
107548    +%mend EM_FREEZE_BINNING;
107550    +%macro EM_EQUAL_SPACED_BINNING(input, bindata, binningCode);
107553    +/* initialize new bucket_binning macro */
107554    +filename temp catalog 'sashelp.emapps.bucket_binning.source';
107555    +%include temp;
107556    +filename temp;
107558    +/* create fileref for generation of binningCode */
107559    +filename X "&binningCode";
107561    +/* determine if there are inputs to be binned */
107562    +%let numbinvars = 0;
107563    +%let intdsid = %sysfunc(open(work._intmid));
107564    +%if &intdsid %then %do;
107565    +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
107566    +%end;
107567    +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
107568    +%if &numbinvars > 0 %then %do;
107571    +/* get data in format needed for quantile_binning macro */
107572    +data work.vartable;
107573    +  set work._intmid;
107574    +  level = "INTERVAL";
107575    +  role  = "INPUT";
107576    +  rename variable=name;
107577    +run;
107579    +/* if freq var exists, add this to vartable so it will be processed by
107579   !+quantile_binning */
107580    +%if %EM_FREQ ne %then %do;
107581    +   data work.freq;
107582    +     name="%EM_FREQ";
107583    +     role="FREQ";
107584    +   run;
107586    +   data work.vartable;
107587    +     set work.vartable work.freq;
107588    +   run;
107589    +%end;
107591    +/* perform bucket binning of data */
107592    +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
107593    +%em_apps_bucket_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS,
107593   !+&EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
107595    +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
107596    +%end;
107597    +%else %do;
107598    +  /* initialize binmappings table */
107599    +  data &EM_USER_BINMAPPINGS;
107600    +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
107601    +  run;
107603    +  data _null_;
107604    +    FILE X;
107606    +    put "&EM_CODEBAR;";
107607    +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
107608    +    put "* &note;";
107609    +    put "&EM_CODEBAR;";
107610    +  run;
107612    +%end;
107614    +/* assign display_var values to binmappings table as well as initial group values */
107615    +data &EM_USER_BINMAPPINGS;
107616    +  set &EM_USER_BINMAPPINGS;
107617    +  length display_var $32 grp $8;
107618    +  display_var = name;
107620    +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
107621    +    GRP = BIN + 1;
107622    +  %end;
107623    +  %else %do;
107624    +    GRP = BIN;
107625    +  %end;
107626    +run;
107628    +/* de-assign fileref */
107629    +filename X;
107631    +    /* append to binning code those values that were included in the importSubset
107631   !+data */
107632    +    %if &useImport eq 1 %then %do;
107633    +      %EM_IMPORT_BINNING(&binningcode);
107634    +    %end;
107636    +    /* append to binning code those values that were included in the freezeSubset
107636   !+data */
107637    +    %if &useFreeze eq 1 %then %do;
107638    +      %EM_FREEZE_BINNING(&binningcode);
107639    +    %end;
107641    +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
107642    +     by NAME;
107643    +     run;
107645    +     /* create grouping for missing level */
107646    +    data tempmissvalues;
107647    +    run;
107649    +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
107650    +       data tempmissvalues;
107651    +         %if &useImport eq 1 %then %do;
107652    +           merge sortedmapping &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME))
107652   !+;
107653    +         %end;
107654    +         %if &useFreeze eq 1 %then %do;
107655    +           merge sortedmapping &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME))
107655   !+;
107656    +         %end;
107657    +         %else %do;
107658    +           set sortedmapping;
107659    +         %end;
107660    +         GRP="1";
107661    +         bin="Missing";
107662    +         _split_value_ = "Missing";
107663    +         %if &useImport eq 1 %then %do;
107664    +            if _a then delete;
107665    +         %end;
107666    +         %if &useFreeze eq 1 %then %do;
107667    +            if _b then delete;
107668    +         %end;
107670    +       run;
107671    +    %end;
107673    +    /* create binData from binningCode */
107674    +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
107675    +      by NAME;
107676    +    run;
107678    +    filename X "&binningCode";
107679    +    data &bindata;
107680    +      set &input;
107681    +      %inc X;
107682    +    run;
107684    +    filename X;
107686    +    /* create splitvals dataset */
107687    +    data tempsplitvals;
107688    +      set &EM_USER_BINMAPPINGS
107689    +        %let tdsid = %sysfunc(open(work.tempmissvalues));
107690    +        %if &tdsid %then %do;
107691    +          tempmissvalues
107692    +        %end;
107693    +        %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
107694    +      ;
107695    +      length newgroup _group_ 8 _level_ $8;
107696    +      newgroup =.;
107697    +      _LEVEL_ = 'ORDINAL';
107698    +      _Group_ = grp;
107699    +      rename NAME=DISPLAY_VAR BIN=_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
107700    +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_;
107701    +    run;
107703    +    data tempsplitvals;
107704    +      set tempsplitvals;
107705    +      _order_ = _N_;
107706    +    run;
107708    +    /* determine if EM_USER_SPLITVALS already exists */
107709    +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
107710    +    %if &sdsid > 0 %then %do;
107711    +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
107712    +      %if &nvars > 0 %then %do;
107713    +        proc sql;
107714    +          reset noprint;
107715    +          select count(*) into :nobs from &EM_USER_SPLITVALS;
107716    +        quit;
107717    +      %end;
107718    +      %else %let nobs=0;
107719    +    %end;
107720    +    %else %do;
107721    +       %let nobs=0;
107722    +       %let nvars=0;
107723    +    %end;
107724    +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
107726    +    /* if useIMport=1 also include import definitions here as well */
107727    +    %if &useImport eq 1 %then %do;
107728    +      data tempImport;
107729    +        set &EM_USER_IMPORTSUBSET;
107730    +        _variable_ = binVar;
107731    +      run;
107732    +    %end;
107734    +    /* if useFreeze=1 also include import definitions here as well */
107735    +    %if &useFreeze eq 1 %then %do;
107736    +      data tempFreeze;
107737    +        length display_var $32;
107738    +        set &EM_USER_FREEZESUBSET;
107739    +        display_var = _variable_;
107740    +        _variable_ = binVar;
107741    +      run;
107742    +    %end;
107745    +    data &EM_USER_SPLITVALS;
107746    +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
107747    +        set &EM_USER_SPLITVALS tempsplitvals
107748    +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
107749    +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
107750    +        %end;
107751    +        %if &useFreeze eq 1 %then %do;
107752    +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
107753    +        %end;
107754    +        ;
107755    +      %end;
107756    +      %else %do;
107757    +        set tempsplitvals
107758    +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
107759    +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
107760    +        %end;
107761    +        %if &useFreeze eq 1 %then %do;
107762    +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
107763    +        %end;
107764    +        ;
107765    +      %end;
107766    +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _ORDER_;
107767    +    run;
107769    +    /* create temporary mapping dataset of normalized and non-normalized values for
107769   !+char variables*/
107770    +    data tempvariableset;
107771    +      set &EM_DATA_VARIABLESET;
107772    +      where TYPE = 'C';
107773    +    run;
107775    +    /* add all interval vars that aren't special codes to the intervalvar macro
107776    +    %let dsid = %sysfunc(open(work.tempvariableset));
107777    +    %if &dsid %then %do;
107778    +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
107779    +      %let obs = %sysfunc(fetch(&dsid));
107780    +      %do %while(&obs=0);
107781    +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
107782    +        %let classvars = &classvars &varname;
107783    +        %let qclassvars = &qclassvars "&varname";
107784    +        %let obs = %sysfunc(fetch(&dsid));
107785    +      %end;
107786    +    %end;
107787    +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
107788    +    */
107789    +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME,
107789   !+nummacro=num_classvars);
107791    +    %if %classvars ne %then %do;
107792    +      proc dmdb data =&bindata classout=_classout nonorm;
107793    +        class %classvars;
107794    +      run;
107796    +      proc dmdb data=&bindata classout=_classout2;
107797    +       class %classvars;
107798    +      run;
107800    +      proc sort data=_classout; by NAME CRAW; run;
107801    +      proc sort data=_classout2; by NAME CRAW; run;
107803    +      data _classout;
107804    +        length _variable_ $32;
107805    +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
107806    +        _split_value_ = trim(left(_split_value_));
107807    +        LEVEL = trim(left(LEVEL));
107808    +        by NAME CRAW;
107809    +       _variable_ = NAME;
107810    +      run;
107812    +      proc sort data=_classout; by _variable_ _split_value_; run;
107813    +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
107815    +      data &EM_USER_SPLITVALS;
107816    +        length _norm_level_ $200 _split_value_ $200;
107817    +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
107818    +        by _variable_ _split_value_;
107819    +        LEVEL = trim(left(LEVEL));
107820    +        _norm_level_ = trim(left(_norm_level_));
107821    +        _split_value_ = trim(left(_split_value_));
107822    +        if _norm_level_ eq '' then _norm_level_= _split_value_;
107823    +        drop NAME FREQUENCY TYPE CRAW NRAW;
107824    +      run;
107826    +      proc datasets library=work nolist;
107827    +        delete _classout _classout2;
107828    +      run;
107829    +      quit;
107830    +    %end;
107831    +    data &EM_USER_SPLITVALS;
107832    +      set &EM_USER_SPLITVALS;
107833    +      if _norm_level_ eq '' then _norm_level_= _split_value_;
107834    +    run;
107836    +    proc sort data=&EM_USER_SPLITVALS;
107837    +      by DISPLAY_VAR _Group_;
107838    +    run;
107840    +   proc datasets library=work nolist;
107841    +     delete tempBinMappings temp_binmappings tempBinNames tempsplitvals
107841   !+sortedmapping tempmissvalues
107842    +      %if &useImport eq 1 %then %do;
107843    +        tempImport
107844    +      %end;
107845    +      %if &useFreeze eq 1 %then %do;
107846    +        tempFreeze
107847    +      %end;
107848    +     ;
107849    +   run;
107850    +   quit;
107852    +%mend;
107854    +%macro EM_QUANTILE_BINNING(input, pctdata, bindata, binningCode);
107856    +/* initialize new quantile_binning macro */
107857    +filename temp catalog 'sashelp.emapps.quantile_binning.source';
107858    +%include temp;
107859    +filename temp;
107861    +/* generate fileref for quantile_binning macro */
107862    +filename X "&binningCode";
107864    +/* determine if there are inputs to be binned */
107865    +%let numbinvars = 0;
107866    +%let intdsid = %sysfunc(open(work._intmid));
107867    +%if &intdsid %then %do;
107868    +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
107869    +%end;
107870    +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
107871    +%if &numbinvars > 0 %then %do;
107873    +/* get data in format needed for quantile_binning macro */
107874    +data work.vartable;
107875    +  set work._intmid;
107876    +  level = "INTERVAL";
107877    +  role  = "INPUT";
107878    +  rename variable=name;
107879    +run;
107881    +/* if freq var exists, add this to vartable so it will be processed by
107881   !+quantile_binning */
107882    +%if %EM_FREQ ne %then %do;
107883    +   data work.freq;
107884    +     name="%EM_FREQ";
107885    +     role="FREQ";
107886    +   run;
107888    +   data work.vartable;
107889    +     set work.vartable work.freq;
107890    +   run;
107891    +%end;
107894    +/* perform quantile binning of data */
107895    +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
107896    +%em_apps_quantile_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS,
107896   !+&EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
107898    +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
107899    +%end;
107900    +%else %do;
107901    +  /* initialize binmappings table */
107902    +  data &EM_USER_BINMAPPINGS;
107903    +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
107904    +  run;
107906    +  data _null_;
107907    +    FILE X;
107909    +    put "&EM_CODEBAR;";
107910    +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
107911    +    put "* &note;";
107912    +    put "&EM_CODEBAR;";
107913    +  run;
107915    +%end;
107917    +/* assign display_var values to binmappings table as well as initial group values */
107918    +data &EM_USER_BINMAPPINGS;
107919    +  set &EM_USER_BINMAPPINGS;
107920    +  length display_var $32 grp $8;
107921    +  display_var = name;
107923    +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
107924    +    GRP = BIN + 1;
107925    +  %end;
107926    +  %else %do;
107927    +    GRP = BIN;
107928    +  %end;
107929    +run;
107931    +/* de-assign fileref */
107932    +filename X;
107934    +    /* append to binning code those values that were included in the importSubset
107934   !+data */
107935    +    %if &useImport eq 1 %then %do;
107936    +      %EM_IMPORT_BINNING(&binningcode);
107937    +    %end;
107939    +    /* append to binning code those values that were included in the freezeSubset
107939   !+data */
107940    +    %if &useFreeze eq 1 %then %do;
107941    +      %EM_FREEZE_BINNING(&binningcode);
107942    +    %end;
107944    +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
107945    +      by NAME;
107946    +    run;
107948    +    /* create grouping for missing level */
107949    +    data tempmissvalues;
107950    +    run;
107952    +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
107953    +       data tempmissvalues;
107954    +         %if ((&useImport eq 1) OR (&useFreeze eq 1)) %then %do;
107955    +           merge sortedmapping
107956    +           %if &useImport eq 1 %then %do;
107957    +              &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME))
107958    +           %end;
107959    +           %if &useFreeze eq 1 %then %do;
107960    +             &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME))
107961    +           %end;
107962    +           ;
107963    +         %end;
107964    +         %else %do;
107965    +           set sortedmapping;
107966    +         %end;
107967    +         GRP="1";
107968    +         bin="Missing";
107969    +         _split_value_ = "Missing";
107970    +         %if &useImport eq 1 %then %do;
107971    +            if _a then delete;
107972    +         %end;
107973    +         %if &useFreeze eq 1 %then %do;
107974    +            if _b then delete;
107975    +         %end;
107977    +       run;
107978    +    %end;
107981    +    /* create binData from binningCode */
107982    +    filename X "&binningCode";
107984    +    data &bindata;
107985    +      set &input;
107986    +      %inc X;
107987    +    run;
107989    +    filename X;
107991    +    /* create splitvals dataset */
107992    +    data tempsplitvals;
107993    +      set &EM_USER_BINMAPPINGS tempmissvalues;
107994    +      length newgroup _group_ _order_ 8 _level_ $8;
107995    +      newgroup =.;
107996    +      _LEVEL_ = 'ORDINAL';
107997    +      _Group_ = grp;
107998    +      rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
107999    +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
108000    +    run;
108002    +    data tempsplitvals;
108003    +      set tempsplitvals;
108004    +      _order_ = _N_;
108005    +    run;
108007    +    /* determine if EM_USER_SPLITVALS already exists */
108008    +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
108009    +    %if &sdsid > 0 %then %do;
108010    +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
108011    +      %if &nvars > 0 %then %do;
108012    +        proc sql;
108013    +          reset noprint;
108014    +          select count(*) into :nobs from &EM_USER_SPLITVALS;
108015    +        quit;
108016    +      %end;
108017    +      %else %let nobs=0;
108018    +    %end;
108019    +    %else %do;
108020    +       %let nobs=0;
108021    +       %let nvars=0;
108022    +    %end;
108023    +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
108025    +    /* if useIMport=1 also include import definitions here as well */
108026    +    %if &useImport eq 1 %then %do;
108027    +      data tempImport;
108028    +        set &EM_USER_IMPORTSUBSET;
108029    +        _variable_ = binVar;
108030    +      run;
108031    +    %end;
108033    +    /* if useFreeze=1 also include frozen definitions here as well */
108034    +    %if &useFreeze eq 1 %then %do;
108035    +      data tempFreeze;
108036    +        length display_var $32;
108037    +        set &EM_USER_FreezeSUBSET;
108038    +        display_var = _variable_;
108039    +        _variable_ = binVar;
108040    +      run;
108041    +    %end;
108043    +    data &EM_USER_SPLITVALS;
108044    +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
108045    +        set &EM_USER_SPLITVALS tempsplitvals
108046    +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
108047    +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
108048    +        %end;
108049    +        %if &useFreeze eq 1 %then %do;
108050    +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
108051    +        %end;
108052    +        ;
108053    +      %end;
108054    +      %else %do;
108055    +        set tempsplitvals
108056    +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
108057    +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
108058    +        %end;
108059    +        %if &useFreeze eq 1 %then %do;
108060    +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
108061    +        %end;
108062    +        ;
108063    +      %end;
108064    +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
108065    +    run;
108067    +    /* create temporary mapping dataset of normalized and non-normalized values for
108067   !+char variables*/
108068    +    data tempvariableset;
108069    +      set &EM_DATA_VARIABLESET;
108070    +      where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y',
108070   !+'D')) OR (ROLE='REJECTED' and USE='Y'));
108071    +    run;
108073    +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME,
108073   !+nummacro=num_classvars);
108075    +    /* add all interval vars that aren't special codes to the intervalvar macro
108076    +    %let dsid = %sysfunc(open(work.tempvariableset));
108077    +    %if &dsid %then %do;
108078    +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
108079    +      %let obs = %sysfunc(fetch(&dsid));
108080    +      %do %while(&obs=0);
108081    +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
108082    +        %let classvars = &classvars &varname;
108083    +        %let qclassvars = &qclassvars "&varname";
108084    +        %let obs = %sysfunc(fetch(&dsid));
108085    +      %end;
108086    +    %end;
108087    +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
108088    +*/
108089    +    %if %classvars ne %then %do;
108090    +      proc dmdb data =&bindata classout=_classout nonorm;
108091    +        class %classvars;
108092    +      run;
108094    +      proc dmdb data=&bindata classout=_classout2;
108095    +       class %classvars;
108096    +      run;
108098    +      proc sort data=_classout; by NAME CRAW; run;
108099    +      proc sort data=_classout2; by NAME CRAW; run;
108101    +      data _classout;
108102    +        length _variable_ $32;
108103    +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
108104    +        by NAME CRAW;
108105    +       _variable_ = NAME;
108106    +      run;
108108    +      proc sort data=_classout; by _variable_ _split_value_; run;
108109    +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
108111    +      data &EM_USER_SPLITVALS;
108112    +        length _norm_level_ $200 _split_value_ $200;
108113    +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
108114    +        by _variable_ _split_value_;
108115    +        LEVEL = trim(left(LEVEL));
108116    +        _split_value_ = trim(left(_split_value_));
108117    +        _norm_level_ = trim(left(_norm_level_));
108118    +        if _norm_level_ eq '' then _norm_level_= _split_value_;
108119    +        drop NAME FREQUENCY TYPE CRAW NRAW;
108120    +      run;
108122    +      proc datasets library=work nolist;
108123    +        delete _classout _classout2;
108124    +      run;
108125    +      quit;
108126    +    %end;
108128    +    data &EM_USER_SPLITVALS;
108129    +      set &EM_USER_SPLITVALS;
108130    +      if _norm_level_ eq '' then _norm_level_= _split_value_;
108131    +    run;
108134    +    proc sort data=&EM_USER_SPLITVALS;
108135    +      by DISPLAY_VAR _Group_;
108136    +    run;
108138    +    proc datasets library=work nolist;
108139    +      delete sortedmapping tempsplitvals tempmissvalues
108140    +      %if &useImport eq 1 %then %do;
108141    +        tempImport
108142    +      %end;
108143    +      %if &useFreeze eq 1 %then %do;
108144    +        tempFreeze
108145    +      %end;
108146    +      ;
108147    +    run;
108148    +    quit;
108149    +/*
108150    +%end;
108151    +%else %do;
108152    +    data &bindata;
108153    +      set &input;
108154    +    run;
108155    +%end;
108156    +*/
108157    +%mend EM_QUANTILE_BINNING;
108159    +%macro EM_ORDVARS_GROUP;
108161    +   /* retrieve all ordinal variables from the incoming dataset */
108162    +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
108163    +     by NAME;
108164    +     where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR
108164   !+(ROLE='REJECTED' and USE='Y'));
108165    +   run;
108167    +   /* add all vars marked as interval that are actually class vars to this data */
108168    +   %let nobs = 0;
108169    +   %let dsid = %sysfunc(open(WORK._DISCRETEMID));
108170    +   %if &dsid %then %do;
108171    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
108172    +     %if &nobs gt 0 %then %do;
108174    +     data tempvars;
108175    +       set &EM_DATA_VARIABLESET;
108176    +       if NAME in (
108177    +         %let obs = %sysfunc(fetch(&dsid));
108178    +         %do %while(&obs=0);
108179    +           %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
108180    +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
108181    +           "&varname"
108182    +           %let obs = %sysfunc(fetch(&dsid));
108183    +         %end;
108184    +        );
108185    +     run;
108186    +     data tempvariableset;
108187    +       set tempvariableset tempvars;
108188    +     run;
108189    +     %end;
108190    +   %end;
108191    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
108193    +   %if &useImport eq 1 %then %do;
108194    +     /* remove all variables from tempvariableset that are included in the
108194   !+importsubset */
108195    +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME))
108195   !+;
108196    +       by _VARIABLE_ ;
108197    +     run;
108198    +     proc sort data=tempvariableset; by NAME; run;
108200    +     data tempvariableset;
108201    +       merge tempimport(in=_a) tempvariableset(in=_b);
108202    +       by NAME;
108203    +       if ^_a then output;
108204    +     run;
108205    +   %end;
108207    +   %if &useFreeze eq 1 %then %do;
108208    +     /* remove all variables from tempvariableset that are included in the
108208   !+freezesubset */
108209    +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME))
108209   !+;
108210    +       by _VARIABLE_ ;
108211    +     run;
108212    +     proc sort data=tempvariableset; by NAME; run;
108214    +     data tempvariableset;
108215    +       merge tempfreeze(in=_a) tempvariableset(in=_b);
108216    +       by NAME;
108217    +       if ^_a then output;
108218    +     run;
108219    +   %end;
108221    +   /* get dataset of distinct values for the ordinal variable */
108222    +   %let nobs = 0;
108223    +   %let dsid = %sysfunc(open(WORK.tempvariableset));
108224    +   %if &dsid %then %do;
108225    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
108226    +     %if &nobs gt 0 %then %do;
108227    +         %let obs = %sysfunc(fetch(&dsid));
108228    +         %do %while(&obs=0);
108229    +           %let varnum = %sysfunc(VARNUM(&dsid, NAME));
108230    +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
108231    +           %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
108232    +           %let input_type = %sysfunc(getvarc(&dsid, &typenum));
108233    +           %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
108234    +           %let input_fmt = %sysfunc(getvarc(&dsid, &fmtnum));
108235    +           %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
108236    +           %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
108237    +           %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
108239    +           data temp;
108240    +             set &EM_USER_BINDATA(keep=&varname);
108241    +             %if &input_fmt ne %then %do;
108242    +               %dmnormcp(put(&varname, &input_fmt), _norm);
108243    +             %end;
108244    +             %else %do;
108245    +               %dmnormcp(&varname, _norm);
108246    +             %end;
108247    +             keep &varname _norm;
108248    +           run;
108250    +          proc dmdb data=temp classout=_classout2;
108251    +           class _norm;
108252    +         run;
108253    +         proc sort data=_classout2; by LEVEL; run;
108255    +         /* re-order numeric inputs based on non-normalized values */
108256    +         %if &input_type eq N %then %do;
108257    +           proc sort data=temp nodupkey; by _norm; run;
108258    +           data varvals;
108259    +             merge temp _classout2(rename=(LEVEL=_norm));
108260    +             by _norm;
108261    +             if craw='' and _norm ne '.' then delete;
108262    +             keep &varname _norm nraw craw;
108263    +           run;
108265    +           proc sort data=varvals; by &varname; run;
108266    +         %end;
108267    +         %else %do;
108268    +           data varvals;
108269    +              set _classout2(rename=(LEVEL=_norm));
108270    +              if _norm='' then delete;
108271    +              if _norm='.' then delete;
108272    +              keep _norm;
108273    +           run;
108274    +         %end;
108275    +         data varvals;
108276    +           set varvals;
108277    +           if &varname="." then delete;
108278    +           if upcase(&varname) = "MISSING" then delete;
108279    +         run;
108281    +          /* generate Splitvals Data */
108282    +          data tempsplitvals;
108283    +            length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_
108283   !+_order_ 8 _level_ $8 _norm_level_ $200 ;
108285    +            %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
108286    +              DISPLAY_VAR="&varname";
108287    +              _VARIABLE_ ="&varname";
108288    +              newgroup   =.;
108289    +              _group_    =1;
108290    +              _Split_Value_="Missing";
108291    +              _level_    ="ORDINAL";
108292    +              output;
108293    +              %let group=2;
108294    +            %end;
108295    +            %else %let group=1;
108297    +            %let vdsid = %sysfunc(open(WORK.VARVALS));
108298    +            %if &vdsid %then %do;
108299    +            %let namenum = %sysfunc(VARNUM(&vdsid, _norm));
108300    +            /*%let group = 2;*/
108301    +            %let vobs = %sysfunc(fetch(&vdsid));
108302    +            %do %while(&vobs=0);
108303    +                %let nameval = %bquote(%upcase(%sysfunc(getvarc(&vdsid, &namenum))))
108303   !+;
108305    +                DISPLAY_VAR   = "&varname";
108306    +                _variable_    = "&varname";
108307    +                newgroup      = .;
108308    +                _group_       = &group;
108309    +                _split_value_ = "&nameval";
108310    +                _level_       = 'ORDINAL';
108311    +                output;
108313    +              %let group = %eval(&group + 1);
108314    +              %let vobs = %sysfunc(fetch(&vdsid));
108315    +            %end;
108316    +            %if &vdsid %then %let vdsid = %sysfunc(close(&vdsid));
108317    +          run;
108319    +          /* determine if EM_USER_SPLITVALS already exists */
108320    +          %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
108321    +          %if &sdsid > 0 %then %do;
108322    +            %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
108323    +            %if &nvars > 0 %then %do;
108324    +               proc sql;
108325    +                reset noprint;
108326    +                select count(*) into :nobs from &EM_USER_SPLITVALS;
108327    +               quit;
108328    +            %end;
108329    +            %else %let nobs=0;
108330    +            %end;
108331    +            %else %do;
108332    +              %let nobs=0;
108333    +              %let nvars=0;
108334    +            %end;
108335    +          %end;
108336    +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
108338    +          /* if tempsplitvals doesn't exist; create empty data set */
108339    +          %let sdsid = %sysfunc(open(work.tempsplitvals));
108340    +          %if &sdsid <= 0 %then %do;
108341    +            data tempsplitvals;
108342    +              length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_
108342   !+8 _level_ $8 ;
108343    +            run;
108344    +          %end;
108345    +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
108347    +          data tempsplitvals;
108348    +            set tempsplitvals;
108349    +            _order_ = _N_;
108350    +          run;
108352    +          %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
108353    +             proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
108354    +             proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_
108354   !+_group_; run;
108355    +          %end;
108357    +          data &EM_USER_SPLITVALS;
108358    +           %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
108359    +             merge &EM_USER_SPLITVALS tempsplitvals;
108360    +             by _variable_ _split_value_;
108361    +           %end;
108362    +           %else %do;
108363    +             set tempsplitvals;
108364    +           %end;
108365    +           if display_var eq "" then delete;
108366    +           if _norm_level_ eq "" then _norm_level_ = _split_value_;
108367    +           keep display_var _split_value_ _variable_ newgroup _group_ _level_
108367   !+_norm_level_ _order_;
108368    +         run;
108370    +           %let obs = %sysfunc(fetch(&dsid));
108371    +         %end;
108372    +     %end;
108373    +   %end;
108374    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
108376    +   proc sort data=&EM_USER_SPLITVALS;
108377    +      by DISPLAY_VAR _Group_;
108378    +   run;
108380    +   /* delete temporary datasets */
108381    +   proc datasets library= work nolist;
108382    +     delete tempsplitvals varvals tempvariableset tempvars
108383    +     ;
108384    +   run;
108385    +   quit;
108386    +%mend EM_ORDVARS_GROUP;
108389    +%macro EM_CLASSVARS_GROUP(groupRare);
108391    +   /* retrieve all class variables from the incoming dataset */
108392    +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
108393    +     by NAME;
108394    +     where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in
108394   !+('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
108395    +   run;
108397    +   %if &useImport eq 1 %then %do;
108398    +     /* remove all variables from tempvariableset that are included in the
108398   !+importsubset */
108399    +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME))
108399   !+;
108400    +       by _VARIABLE_ ;
108401    +     run;
108402    +     proc sort data=tempvariableset; by NAME; run;
108404    +     data tempvariableset;
108405    +       merge tempimport(in=_a) tempvariableset(in=_b);
108406    +       by NAME;
108407    +       if ^_a then output;
108408    +     run;
108409    +   %end;
108411    +   %if &useFreeze eq 1 %then %do;
108412    +     /* remove all variables from tempvariableset that are included in the
108412   !+freezesubset */
108413    +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME))
108413   !+;
108414    +       by _VARIABLE_ ;
108415    +     run;
108416    +     proc sort data=tempvariableset; by NAME; run;
108418    +     data tempvariableset;
108419    +       merge tempfreeze(in=_a) tempvariableset(in=_b);
108420    +       by NAME;
108421    +       if ^_a then output;
108422    +     run;
108423    +   %end;
108425    +   /* run dmdb to retrieve list of all class levels and counts */
108426    +   %let dsid = %sysfunc(open(work.tempvariableset));
108427    +   %let nobs = 0;
108428    +   %if &dsid %then %do;
108429    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
108431    +   %end;
108433    +   %if &nobs gt 0 %then %do;
108434    +     proc dmdb data=&EM_IMPORT_DATA classout=tempclassout;
108435    +       class
108437    +        %let namenum = %sysfunc(VARNUM(&dsid, NAME));
108438    +        %let obs = %sysfunc(fetch(&dsid));
108439    +        %do %while(&obs=0);
108440    +           %let name = %sysfunc(getvarc(&dsid, &namenum));
108441    +           &name
108442    +           %let obs = %sysfunc(fetch(&dsid));
108443    +        %end;
108444    +     ;
108446    +     %if %EM_FREQ ne %then %do;
108447    +        freq %EM_FREQ;
108448    +     %end;
108449    +    run;
108450    +   %end;
108451    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
108453    +   %let dsid = %sysfunc(open(work.tempclassout));
108454    +   %let nobs = 0;
108455    +   %if &dsid %then %do;
108456    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
108457    +     %let dsid = %sysfunc(close(&dsid));
108458    +   %end;
108460    +   %if &nobs gt 0 %then %do;
108461    +    data tempclassout;
108462    +       set tempclassout;
108463    +       if LEVEL='MISSING' then level='Missing';
108464    +    run;
108466    +    proc sort data=tempclassout nodupkey;
108467    +      by NAME descending FREQUENCY LEVEL;
108468    +    run;
108470    +    data tempds(keep=NAME NOBS);
108471    +      retain NOBS;
108472    +      set tempclassout;
108473    +      by NAME;
108474    +      if first.NAME then
108475    +        NOBS = frequency;
108476    +      else
108477    +        NOBS=NOBS+frequency;
108478    +      if last.name then do;
108479    +        output;
108480    +      end;
108481    +    run;
108483    +    data tempds;
108484    +      merge tempclassout
108485    +      tempds;
108486    +      by NAME;
108487    +      if ((LEVEL ne '') AND (LEVEL ne "."));
108488    +      %if &groupRare eq Y %then %do;
108489    +        PCT = 100 * (FREQUENCY/NOBS);
108490    +        if PCT < &EM_PROPERTY_GROUPCUTOFF then flag=1;
108491    +        else flag=0;
108492    +      %end;
108493    +      %else %do;
108494    +        flag = 0;
108495    +      %end;
108496    +    run;
108498    +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
108499    +      data tempmissvalues;
108500    +        length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
108502    +      %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
108503    +      %if &dsid %then %do;
108504    +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
108505    +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
108506    +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
108507    +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
108508    +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
108509    +        %let obs = %sysfunc(fetch(&dsid));
108511    +        %do %while(&obs=0);
108512    +          %let var = %sysfunc(getvarc(&dsid, &varnum));
108513    +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
108514    +          %let type = %sysfunc(getvarc(&dsid, &typenum));
108515    +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
108517    +          NAME="&var";
108518    +          LEVEL="Missing";
108519    +          _LEVEL_="&varlvl";
108520    +          _group_ = 1;
108521    +          output;
108523    +          %let obs = %sysfunc(fetch(&dsid));
108524    +        %end;
108525    +      %end;
108526    +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
108527    +      run;
108528    +    %end;
108530    +    /* generate Splitvals Data */
108531    +    data tempsplitvals;
108532    +      length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
108534    +      set tempclassout
108535    +      %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
108536    +         tempmissvalues
108537    +      %end;
108538    +      ;
108539    +      if ((level ne '') AND (level ne '.'));
108541    +     %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
108542    +     %if &dsid %then %do;
108543    +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
108544    +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
108545    +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
108546    +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
108547    +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
108548    +        %let obs = %sysfunc(fetch(&dsid));
108550    +        %do %while(&obs=0);
108551    +          %let var = %sysfunc(getvarc(&dsid, &varnum));
108552    +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
108553    +          %let type = %sysfunc(getvarc(&dsid, &typenum));
108554    +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
108556    +          if NAME = "&var" then do;
108557    +            _LEVEL_ = "&varlvl";
108559    +          /* cycle through levels, assigning group values;              */
108560    +          /* flag=1 indicates to put value in "_OTHER_" group;          */
108561    +          /* flag=0 indicates that value shoudld be in group of its own */
108562    +          %let choice = ((NAME="&Var") and (FLAG=0));
108563    +          %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
108564    +            %let group=2;
108565    +          %end;
108566    +          %else %do;
108567    +            %let group = 1;
108568    +          %end;
108569    +          %let fdsid = %sysfunc(open(work.tempds(where=(&choice))));
108570    +          %if &fdsid %then %do;
108572    +            %let lvlnum = %sysfunc(VARNUM(&fdsid, LEVEL));
108573    +            %let fobs = %sysfunc(fetch(&Fdsid));
108574    +            %let fflag = 0;
108575    +            %do %while(&fobs=0);
108576    +              %let fflag = 1;
108577    +              %let temp = %nrbquote(%sysfunc(getvarc(&fdsid, &lvlnum)));
108578    +              %let level = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
108579    +              %let level = %nrbquote(%sysfunc(strip(&level)));
108580    +              %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
108581    +                %if &group eq 2 %then %do;
108582    +                   if LEVEL = "&level" then _GROUP_ = &group;
108583    +                %end;
108584    +                %else %do;
108585    +                   else if LEVEL = "&level" then _GROUP_ = &group;
108586    +                %end;
108587    +              %end;
108588    +              %else %do;
108589    +                %if &group eq 1 %then %do;
108590    +                   if LEVEL = "&level" then _GROUP_ = &group;
108591    +                %end;
108592    +                %else %do;
108593    +                   else if LEVEL = "&level" then _GROUP_ = &group;
108594    +                %end;
108595    +              %end;
108597    +              %let group = %eval(&group + 1);
108598    +              %let fobs = %sysfunc(fetch(&fdsid));
108599    +            %end;
108601    +          %end;
108602    +          %if &fflag eq 1 %then %do;
108603    +            else if LEVEL ^='Missing' then _GROUP_ = &group;
108604    +          %end;
108605    +          end;
108607    +          %if &fdsid %then %let fdsid = %sysfunc(close(&fdsid));
108608    +          %let obs = %sysfunc(fetch(&dsid));
108609    +        %end;
108610    +     %end;
108611    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
108612    +     _VARIABLE_ = NAME;
108613    +     newgroup = .;
108614    +     rename NAME = DISPLAY_VAR
108615    +            LEVEL = _SPLIT_VALUE_;
108616    +     keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
108617    +    run;
108618    +  %end;
108619    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
108621    +    /* determine if EM_USER_SPLITVALS already exists */
108622    +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
108623    +    %if &sdsid > 0 %then %do;
108624    +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
108625    +      %if &nvars > 0 %then %do;
108626    +        proc sql;
108627    +          reset noprint;
108628    +          select count(*) into :nobs from &EM_USER_SPLITVALS;
108629    +        quit;
108630    +      %end;
108631    +      %else %let nobs=0;
108632    +    %end;
108633    +    %else %do;
108634    +       %let nobs=0;
108635    +       %let nvars=0;
108636    +    %end;
108637    +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
108639    +   /* if tempsplitvals doesn't exist; create empty data set */
108640    +    %let sdsid = %sysfunc(open(work.tempsplitvals));
108641    +    %if &sdsid <= 0 %then %do;
108642    +      data tempsplitvals;
108643    +        length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
108644    +      run;
108645    +    %end;
108646    +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
108648    +    %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
108649    +      proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
108650    +      proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_;
108650   !+run;
108651    +    %end;
108653    +    /* if useIMport=1 also include import definitions here as well */
108654    +    %if &useImport eq 1 %then %do;
108655    +      proc sort data=&EM_USER_IMPORTSUBSET; by _variable_ _split_value_; run;
108656    +    %end;
108657    +    %if &useFreeze eq 1 %then %do;
108658    +      proc sort data=&EM_USER_FREEZESUBSET; by _variable_ _split_value_; run;
108659    +    %end;
108660    +    data &EM_USER_SPLITVALS;
108661    +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
108662    +        merge &EM_USER_SPLITVALS tempsplitvals
108663    +        %if &useImport eq 1 %then %do;
108664    +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
108665    +        %end;
108666    +        %if &useFreeze eq 1 %then %do;
108667    +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
108668    +        %end;
108670    +        ;
108671    +        by _variable_ _split_value_
108672    +        ;
108673    +      %end;
108674    +      %else %do;
108675    +        set tempsplitvals
108676    +        %if &useImport eq 1 %then %do;
108677    +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
108678    +        %end;
108679    +        %if &useFreeze eq 1 %then %do;
108680    +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
108681    +        %end;
108682    +        ;
108683    +      %end;
108684    +      if display_var eq "" then delete;
108685    +      if _norm_level_ eq "" then _norm_level_ = _split_value_;
108686    +      keep display_var _split_value_ _variable_ newgroup _group_ _level_
108686   !+_norm_level_;
108687    +    run;
108689    +    proc sort data=&EM_USER_SPLITVALS;
108690    +      by DISPLAY_VAR _Group_;
108691    +    run;
108693    +   /* delete temporary datasets */
108694    +   proc datasets library= work nolist;
108695    +     delete tempsplitvals tempds tempclassout tempvariableset tempvars
108696    +     %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
108697    +       tempmissvalues
108698    +     %end;
108699    +     ;
108700    +   run;
108701    +   quit;
108702    +%mend EM_CLASSVARS_GROUP;
108705    +%macro EM_SUMMARIZE_TABLE(data, inputData, outData, varname=);
108707    +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
108709    +  data temptrain ;
108710    +    set &data;
108711    +  run;
108713    +  /* normalize all values prior to calculating counts */
108714    +  filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
108715    +  %include _temp;
108716    +  filename _temp;
108717    +  filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
108718    +  %include _temp;
108719    +  filename _temp;
108721    +  proc sort data=&EM_USER_VARMAPPINGS
108722    +  %if &varname ne %then %do;
108723    +    (where=(_variable_="&varname"))
108724    +  %end;
108725    +  out=tempmap; by _variable_; run;
108727    +  data _cmeta;
108728    +    merge tempvarset tempmap(in=_a rename=(_variable_=name ));
108729    +    by name;
108730    +    if ((_a) or (role="TARGET"));
108731    +    if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
108732    +    %if %length(%EM_BINARY_TARGET) %then %do;
108733    +      if role="TARGET" then role="INPUT";
108734    +    %end;
108735    +    level = procLevel;
108736    +    index = kindex(name, "BIN_");
108737    +    if index gt 0 then do;
108738    +     level="ORDINAL";
108739    +     format = "";
108740    +    end;
108741    +    drop index;
108742    +  run;
108744    +  %em_PreNormalizeClassVars(incmeta=_cmeta, outcmeta=_cmetatmp);
108745    +  %em_NormalizeClassVars(indata=work.temptrain, cmeta=_cmetatmp, encodedTarget=N,
108745   !+outdata=_tmp_train);
108747    +  proc sort data=&inputData out=sortedmap; by _proc_var_; run;
108749    +  data _null_;
108750    +    set sortedmap end=eof;
108751    +    by _proc_var_;
108752    +    if _n_=1 then do;
108753    +      call execute("ods output CrossTabFreqs=crosstabfreq ;");
108754    +      call execute("ods listing close;");
108755    +      call execute("proc freq data=_tmp_train order=formatted addnames;");
108756    +      call execute("tables ("||_proc_var_);
108757    +    end;
108758    +    else do;
108759    +      call execute(_proc_var_);
108760    +    end;
108761    +    if eof then do;
108762    +      call execute(") * &ignbintarget/ missing;");
108763    +      %if %EM_FREQ ne %then %do;
108764    +        call execute("weight %EM_FREQ;");
108765    +      %end;
108766    +      call execute("run;");
108767    +      call execute("ods output close;");
108768    +      call execute("ods listing;");
108769    +    end;
108770    +  run;
108772    +  data _null_;
108773    +    set sortedmap end=eof;
108774    +    by _proc_var_;
108775    +    if _n_=1 then do;
108776    +      call execute("data crosstabs;");
108777    +      call execute("  length _variable_ _split_value_  $200 ;");
108778    +      call execute("  set crosstabfreq(where=(_type_='11'));");
108779    +      call execute("  _variable_= RowVariable;");
108780    +    end;
108782    +    call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
108783    +    call execute("  _split_value_="||_proc_var_||";");
108784    +    call execute("end;");
108786    +    if eof then do;
108787    +      call execute("keep _variable_ _split_value_ &ignbintarget Frequency Percent
108787   !+display_var;");
108788    +      call execute("run;");
108789    +    end;
108790    +  run;
108792    +  proc sort data=crosstabs; by _variable_ _split_value_; run;
108794    +  data crosstabs;
108795    +    length display_var $32;
108796    +    merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ )
108796   !+ keep=_variable_ _proc_var_ );
108797    +    by _variable_;
108798    +  run;
108800    +  proc sort data=crosstabs; by display_var _split_value_; run;
108801    +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
108803    +  data crosstabs;
108804    +    merge crosstabs tempvarset(rename=(name=display_var) keep=type format name
108804   !+level);
108805    +    by display_var;
108806    +    index = kindex(_variable_, "BIN_");
108807    +    if index gt 0 then do;
108808    +     level="ORDINAL";
108809    +     format = "";
108810    +    end;
108811    +    _temp = &ignbintarget;
108812    +    /*
108813    +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
108814    +      %if &target_format ne %then %do;
108815    +        %if &target_type eq C %then %do;
108816    +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
108817    +        %end;
108818    +        %else %do;
108819    +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
108820    +        %end;
108821    +      %end;
108822    +      %else %do;
108823    +        %dmnormcp(&ignbintarget, _temp);
108824    +      %end;
108825    +    %end;
108826    +    %else %do;
108827    +      _temp = &ignbintarget;
108828    +    %end;
108829    +*/
108831    +    drop index;
108832    +  run;
108834    +  proc sort data=crosstabs; by _variable_ _split_value_; run;
108836    +  data &outdata;
108837    +    length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate
108837   !+nonEventRate  8 type $1 valfmt $20 ;
108839    +    retain eventCount noneventCount ;
108840    +    set crosstabs;
108841    +    by  _variable_ _split_value_;
108843    +    if first._split_value_ then do;
108844    +     total=0;
108845    +     eventcount=0;
108846    +     noneventcount=0;
108847    +    end;
108849    +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
108850    +      %if &target_format ne %then %do;
108851    +        if upcase(strip(_temp))="&target_event" then
108852    +          eventCount=Frequency;
108853    +      %end;
108854    +      %else %do;
108855    +         if upcase(strip(_temp)) ="&target_event" then
108856    +          eventCount=Frequency;
108857    +      %end;
108858    +    %end;
108859    +    %else %do;
108860    +      if _temp=&target_event then
108861    +        eventCount=Frequency;
108862    +    %end;
108863    +    else
108864    +      noneventCount=Frequency;
108866    +    if last._split_value_ then do;
108867    +      total = eventCount + noneventCount;
108869    +      if total ne 0 then do;
108870    +        eventRate = eventCount / total;
108871    +        nonEventRate = nonEventCount / total;
108872    +      end;
108873    +      else do;
108874    +        eventRate = 0;
108875    +        nonEventRate = 0;
108876    +      end;
108877    +     output;
108878    +    end;
108879    +    valfmt = format;
108881    +    drop _temp Frequency percent;
108882    +   run;
108884    +%mend EM_SUMMARIZE_TABLE;
108887    +%macro EM_FINE_DETAIL(bindata, varmappings, fineDetailData, splitVals, binMappings,
108887   !+interactiveFlag=0);
108889    +   proc freq data=&bindata noprint;
108890    +     table &ignbintarget / missing out=temptargetB;
108891    +     %if %EM_FREQ ne %then %do;
108892    +       weight %EM_FREQ;
108893    +     %end;
108894    +   run;
108896    +   %let tdsid = %sysfunc(open(work.temptargetB));
108897    +   %if &tdsid %then %do;
108898    +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
108899    +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
108901    +      %let temp = %nrbquote(%sysfunc(strip(&target_event)));
108902    +      %let target_event = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
108903    +      %let temp = %nrbquote(%sysfunc(strip(&target_nonevent)));
108904    +      %let target_nonevent = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
108907    +      %let obs = %sysfunc(fetch(&tdsid));
108908    +      %do %while(&obs = 0);
108909    +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
108910    +           %if &target_type eq C %then %do;
108911    +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
108912    +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
108913    +           %end;
108914    +           %else
108915    +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
108917    +           %if &target_format ne %then %do;
108918    +              %if &target_type eq C %then %do;
108919    +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue),
108919   !+&target_format)));
108920    +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
108921    +              %end;
108922    +              %else
108923    +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
108924    +           %end;
108925    +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
108926    +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
108928    +           %if "&tarvalue" eq "&target_event" %then %do;
108929    +             %let totalevent = &count;
108930    +           %end;
108931    +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
108932    +              %let totalnonevent= &count;
108933    +           %end;
108934    +         %end;
108935    +         %else %do;
108936    +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
108937    +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
108939    +           %if &tarvalue eq &target_event %then %do;
108940    +             %let totalevent = &count;
108941    +           %end;
108942    +           %else %if &tarvalue eq &target_nonevent %then %do;
108943    +              %let totalnonevent= &count;
108944    +           %end;
108945    +         %end;
108946    +         %let obs = %sysfunc(fetch(&tdsid));
108947    +      %end;
108948    +   %end;
108949    +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
108951    +   proc datasets lib=work nolist;
108952    +      delete temptargetB;
108953    +   run;
108954    +   quit;
108956    +   %if &interactiveFlag eq 0 %then %do;
108957    +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData);
108958    +   %end;
108959    +   %else %do;
108960    +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData, varname=&wherevar)
108960   !+;
108961    +   %end;
108964    +   data &fineDetailData;
108965    +     length display_var $32 newgroup numsplitval 8;
108966    +     set &fineDetailData;
108968    +     display_var = _variable_;
108970    +     index = kindex(display_var, "BIN_");
108971    +     if index gt 0 then do;
108972    +       display_var = ksubstr(display_var, 5);
108973    +     end;
108975    +     index2 = kindex(display_var, "SV_");
108976    +     if index2 gt 0 then do;
108977    +       display_var = ksubstr(display_var, 4);
108978    +     end;
108980    +     /* re-code missing values to "Missing" */
108981    +     if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = "."))
108981   !+then _SPLIT_VALUE_="MISSING";
108982    +     _index_ = _N_;
108983    +     newgroup = .;
108984    +     drop index index2 ;
108985    +   run;
108987    +   /* add group information to fineDetailData; */
108988    +   /* add label information for binned variables to fineDetailData*/
108990    +   proc sort data=&fineDetailData; by _variable_ _split_value_; run;
108992    +   data tmpsplitvals;
108993    +     set &splitvals;
108994    +     _norm_level_ = upcase(_norm_level_);
108995    +     if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
108996    +    * drop _split_value_;
108997    +   run;
108999    +   proc sort data=tmpsplitvals out=sortedsplit; by _variable_ _split_value_; run;
109000    +   proc datasets library=work nolist;
109001    +     delete tmpsplitvals;
109002    +   run;
109003    +   quit;
109005    +   proc sort data=&BINMAPPINGS out=sortedbin; by BIN_NAME BIN; run;
109007    +   data &fineDetailData;
109008    +      merge &fineDetailData(in=_c) work.sortedsplit(in=_b)
109008   !+work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
109009    +      by _variable_ _split_value_;
109010    +      if _a then do;
109011    +        binFlag = 1;
109012    +        VALUE=EM_BIN_LABEL;
109013    +      end;
109014    +      else do;
109015    +        binFlag = 0;
109016    +        *VALUE=strip(display_var)!!"="!!strip(_split_value_);
109017    +        VALUE=strip(_split_value_);
109019    +      end;
109021    +      if ((eventCount=.) or (nonEventCount=.)) then do;
109022    +        eventCount=0;
109023    +        nonEventCount=0;
109024    +        total = 0;
109025    +        eventRate= 0;
109026    +        nonEventRate = 0;
109027    +      end;
109029    +      eventCount = round(eventCount, .001);
109030    +      nonEventCount = round(nonEventCount, .001);
109031    +      total= round(total, .001);
109032    +      eventRate = round(eventRate, .001);
109033    +      nonEventRate = round(nonEventRate, .001);
109035    +     if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then
109036    +         numsplitval = _split_value_;
109037    +     else if ((type='N') AND (valfmt ne "")) then
109038    +        numsplitval = _order_;
109039    +     else numsplitval=.;
109041    +      if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
109042    +      if _a and ^_b then delete;
109043    +      if _c and ^_b then delete;
109044    +      drop NAME EM_BIN_LABEL valfmt;
109045    +   run;
109047    +   /* for class variables that have values falling into the "other" category, set
109047   !+_LEVEL_ and _GROUP_ based on Missing level */
109048    +   data &fineDetailData;
109049    +     set &fineDetailData;
109051    +     %let choice = _LEVEL_ ne "INTERVAL" and _SPLIT_VALUE_ eq "Missing";
109052    +     %let dsid = %sysfunc(open(&splitvals(where=(&choice))));
109053    +     %if &dsid %then %do;
109054    +       %let dnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
109055    +       %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
109056    +       %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
109058    +       %let obs = %sysfunc(fetch(&dsid));
109059    +       %do %while(&obs=0);
109060    +         %let dispvar = %sysfunc(getvarc(&dsid, &dnum));
109061    +         %let lvl     = %sysfunc(getvarc(&dsid, &lvlnum));
109062    +         %let group   = %sysfunc(getvarn(&dsid, &grpnum));
109064    +         if DISPLAY_VAR = "&dispvar" then do;
109065    +           if _LEVEL_ = "" then _LEVEL_ ="&lvl";
109066    +           if _GROUP_ = . then _GROUP_ = &group;
109067    +         end;
109069    +         %let obs = %sysfunc(fetch(&dsid));
109070    +       %end;
109071    +     %end;
109072    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
109073    +     if _GROUP_ = . then delete;
109074    +    * if binFlag=1 and UB=LB then delete;
109075    +    * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
109076    +   run;
109078    +   proc sort data=&fineDetailData;
109079    +     by DISPLAY_VAR _index_;
109080    +   run;
109082    +   proc datasets lib=work nolist;
109083    +     delete sortedsplit sortedbin
109084    +     ;
109085    +   run;
109086    +   quit;
109087    +%mend EM_FINE_DETAIL;
109089    +%macro EM_CREATE_GROUPING(bindata, fineDetailData, coarse);
109091    +   proc freq data=&bindata noprint;
109092    +     table &ignbintarget / missing out=temptargetC;
109093    +     %if %EM_FREQ ne %then %do;weight %EM_FREQ;
109094    +     %end;
109095    +   run;
109097    +   %let tdsid = %sysfunc(open(work.temptargetC));
109098    +   %if &tdsid %then %do;
109099    +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
109100    +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
109102    +      %let obs = %sysfunc(fetch(&tdsid));
109103    +      %do %while(&obs = 0);
109104    +        /* %if &target_type eq C or &target_format ne %then %do; */
109105    +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
109106    +           %if &target_type eq C %then %do;
109107    +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
109108    +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
109109    +           %end;
109110    +           %else
109111    +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
109113    +           %if &target_format ne %then %do;
109114    +              %if &target_type eq C %then %do;
109115    +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue),
109115   !+&target_format)));
109116    +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
109117    +              %end;
109118    +              %else
109119    +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
109120    +           %end;
109121    +           %let tarvalue =%nrbquote(%upcase(&tarvalue));
109122    +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
109124    +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
109125    +           %let target_event = %nrbquote(%sysfunc(strip(&target_event)));
109126    +           %let target_nonevent = %nrbquote(%sysfunc(strip(&target_nonevent)));
109128    +           %if "&tarvalue" eq "&target_event" %then %do;
109129    +             %let totalevent = &count;
109130    +           %end;
109131    +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
109132    +              %let totalnonevent= &count;
109133    +           %end;
109134    +         %end;
109135    +         %else %do;
109136    +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
109137    +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
109139    +           %if &tarvalue eq &target_event %then %do;
109140    +             %let totalevent = &count;
109141    +           %end;
109142    +           %else %if &tarvalue eq &target_nonevent %then %do;
109143    +              %let totalnonevent= &count;
109144    +           %end;
109145    +         %end;
109146    +         %let obs = %sysfunc(fetch(&tdsid));
109147    +      %end;
109148    +   %end;
109149    +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
109151    +   proc datasets lib=work nolist;
109152    +      delete temptargetC;
109153    +   run;
109154    +   quit;
109156    +   proc means data=&FINEDETAILDATA noprint;
109157    +      var eventCount nonEventCount;
109158    +      class _variable_  _group_;
109159    +      output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
109160    +   run;
109162    +   proc sort data=summ(drop=_type_ _freq_);
109163    +     by _variable_ _group_;
109164    +   run;
109166    +   data gini(keep=_variable_ eventCount nonEventCount groupresprate)
109167    +        tempcoarse(keep=_variable_  _group_ eventCount nonEventCount groupresprate
109167   !+groupNonRespRate eventRate nonEventRate respper nrespper);
109168    +        set summ;
109169    +        *format groupresprate 6.2;
109170    +        *format groupnonresprate 6.2;
109171    +        by _variable_ ;
109172    +        if _group_=. then do;
109173    +        end;
109174    +        else do;
109175    +           respper = eventCount / &totalEvent;
109176    +           nrespper = nonEventCount / &totalNonEvent;
109178    +           if ((nonEventCount = 0) AND (eventCount = 0)) then do;
109179    +                groupresprate=0;
109180    +                groupNonresprate = 0;
109181    +                eventRate = 0;
109182    +                nonEventRate = 0;
109183    +           end;
109184    +           else do;
109185    +               groupresprate = eventCount / (eventCount + nonEventCount) ;
109186    +               groupNonRespRate = 1 - groupRespRate;
109187    +               eventRate = eventCount / &totalEvent ;
109188    +               nonEventRate = nonEventCount / &totalNonEvent ;
109189    +            end;
109191    +           output gini tempcoarse;
109193    +        end;
109194    +   run;
109195    +   proc sort data=gini;
109196    +      by _variable_ descending groupresprate;
109197    +   run;
109199    +   data gini(keep= _variable_ _gini_);
109200    +     retain between within cumresp cumnresp;
109201    +     set gini(keep=_variable_  eventCount nonEventCount);
109202    +     by _variable_;
109203    +     if first._variable_ then do;
109204    +       between  = 0;
109205    +       within   = 0;
109206    +       cumresp  = 0;
109207    +       cumnresp = 0;
109208    +     end;
109209    +     between + 2 * cumnresp * eventCount;
109210    +     within + nonEventCount * eventCount;
109211    +     cumresp + eventCount;
109212    +     cumnresp + nonEventCount;
109213    +     if last._variable_ then do;
109214    +       if ^(cumnresp=0 or cumresp=0) then do;
109215    +         _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
109216    +         output;
109217    +       end;
109218    +     end;
109219    +   run;
109221    +   data tempdisplayvar;
109222    +      set &EM_USER_VARMAPPINGS;
109223    +      rename _variable_ = display_var
109224    +      _proc_var_ = _variable_;
109225    +   keep _variable_ _proc_var_ label;
109226    +   run;
109227    +   proc sort data=tempdisplayvar; by _variable_; run;
109229    +   data  &COARSE;
109230    +     length display_Var $32 label _label_ $200 role $10 _group_ 8;
109231    +     merge tempdisplayvar tempcoarse gini ;
109232    +     by _variable_;
109233    +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel ,
109233   !+NOQUOTE))"
109234    +           eventRate   = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventrate_vlabel ,
109234   !+NOQUOTE))"
109235    +           nonEventRate = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventrate_vlabel ,
109235   !+NOQUOTE))"
109236    +           _group_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_group_vlabel ,
109236   !+NOQUOTE))"
109237    +           role       = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel ,
109237   !+NOQUOTE))"
109238    +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_gini_vlabel  ,
109238   !+NOQUOTE))"
109239    +           eventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventcount_vlabel  ,
109239   !+NOQUOTE))"
109240    +           noneventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventcount_vlabel
109240   !+ , NOQUOTE))"
109241    +           groupresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupresprate_vlabel
109241   !+ , NOQUOTE))"
109242    +           groupnonresprate = "%sysfunc(sasmsg(sashelp.dmine,
109242   !+rpt_groupnonresprate_vlabel  , NOQUOTE))"
109243    +           ;
109245    +    eventCount = round(eventCount, .001);
109246    +    nonEventCount = round(nonEventCount, .001);
109247    +    groupRespRate = round(groupRespRate, .001);
109249    +     drop _variable_ index index2 respper nrespper;
109250    +   run;
109252    +   proc datasets library=work nolist;
109253    +     delete  tempcoarse gini             ;
109255    +   run;
109256    +   quit;
109258    +%mend EM_CREATE_GROUPING;
109262    +%macro EM_GENERATE_LABELVALUES(filename, splitvals, binmappings, coarse);
109264    +         data _null_;
109265    +            FILE &filename;
109266    +            put " length _LABEL_ $200;";
109267    +            put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine,
109267   !+rpt_groupvalues_vlabel , NOQUOTE))";';
109268    +         run;
109270    +         proc sort data=&SPLITVALS out=work.sortedsplitval; by display_var
109270   !+_split_Value_; run;
109271    +         proc sort data=&BINMAPPINGS; by display_var bin; run;
109273    +         data temp;
109274    +           merge work.sortedsplitval(in=_a) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_
109274   !+ BIN=_SPLIT_VALUE_));
109275    +           by Display_Var _Split_value_;
109276    +           if upcase(_Split_value_) ne 'MISSING';
109277    +           if _a then output;
109278    +           if display_var eq '' then delete;
109279    +         run;
109281    +         data temp_missing;
109282    +           merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP))
109282   !+&BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
109283    +           by Display_Var _Split_value_;
109284    +           if upcase(_Split_value_) eq 'MISSING';
109285    +           if _a then output;
109286    +           keep _variable_ display_var missgrp;
109287    +         run;
109289    +         proc sort data=temp out=class;
109290    +            by _variable_ _group_ LB;
109291    +         run;
109293    +         data _null_;
109295    +            file &filename MOD;
109296    +            length string $200 flag 8;
109297    +            retain string flag;
109298    +            set class end=eof;
109299    +            by _variable_  _group_;
109301    +            index = kindex(_variable_, "BIN_");
109302    +            if index gt 0 then do;
109303    +              if first._group_ then do;
109304    +                flag = 0;
109305    +                if ^first._variable_ then
109306    +                    put 'else';
109307    +                 else
109308    +                    put ' ';
109310    +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
109311    +                          !!strip(put(_GROUP_,best12.))!!' then do;';
109312    +                 put string;
109314    +                 if LB ne . then do;
109315    +                   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<=
109315   !+"!!strip(DISPLAY_VAR);
109316    +                    string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
109317    +                 end;
109318    +                 else do;
109319    +                    flag = 1;
109320    +                    *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
109321    +                    string = " _LABEL_='"!!strip(DISPLAY_VAR);
109322    +                 end;
109324    +              end;
109325    +              if last._Group_ then do;
109326    +                 if UB ne . then do;
109327    +                    string = strip(string)!!'< '!!strip(UB)!!"';";
109328    +                 end;
109329    +                 else do;
109330    +                    if flag=1 then do;
109331    +                      string = strip(string)!!"';";
109332    +                     /* string = strip(string)!!'='!!strip(_split_Value_)!!"';";*/
109333    +                    end;
109334    +                    else do;
109335    +                      string = strip(string)!!"';";
109336    +                    end;
109337    +                 end;
109338    +                 put string;
109340    +                 string= " UB="!!strip(UB)!!";";
109341    +                 put string;
109342    +                 put "end;";
109345    +              end;
109346    +            end;
109347    +            else do;
109348    +              _split_value_ = tranwrd(_split_value_,"'","''");
109349    +              if first._group_ then do;
109350    +                 flag = 0;
109351    +                 if ^first._variable_ then
109352    +                    put 'else';
109353    +                 else
109354    +                    put ' ';
109355    +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
109356    +                          !!strip(put(_GROUP_,best12.))!!' then';
109357    +                 put string;
109358    +                 string = "_LABEL_='"!!strip(_split_value_);
109359    +              end;
109360    +              else do;
109361    +                 if flag ne 1 then do;
109362    +                   tempstring = strip(string)!!', '!!strip(_split_value_);
109363    +                   length = length(tempstring);
109365    +                   if length < 195 then do;
109366    +                      string = tempstring;
109367    +                   end;
109368    +                   else do;
109369    +                      string = strip(string)||",...";
109370    +                      flag=1;
109371    +                   end;
109372    +                 end;
109373    +              end;
109375    +              if last._group_ then do;
109376    +                 string = strip(string)!!"';";
109377    +                 put string;
109378    +              end;
109379    +            end;
109380    +         run;
109382    +         data &COARSE;
109383    +           set &COARSE;
109384    +          /* %inc Y; */
109385    +           %inc &filename;
109386    +         run;
109387    +         *filename Y;
109389    +         /* add missing to appropriate label - based on temp_missing data */
109390    +         data &COARSE;
109391    +           set &COARSE;
109393    +           %let dsid = %sysfunc(open(work.temp_missing));
109394    +           %if &dsid %then %do;
109395    +              %let varnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
109396    +              %let grpnum = %sysfunc(VARNUM(&dsid, MISSGRP));
109398    +              %let obs = %sysfunc(fetch(&dsid));
109399    +              %do %while(&obs=0);
109400    +                 %let var = %sysfunc(getvarc(&dsid, &varnum));
109401    +                 %let grp = %sysfunc(getvarn(&dsid, &grpnum));
109403    +                 if DISPLAY_VAR = "&var" and _GROUP_ = &grp then do;
109404    +                   if _LABEL_ eq '' then do;
109405    +                     _LABEL_ = "Missing";
109406    +                   end;
109407    +                   else do;
109408    +                     _LABEL_ = strip(_LABEL_)!!", Missing";
109409    +                   end;
109410    +                 end;
109411    +                 %let obs = %sysfunc(fetch(&dsid));
109412    +              %end;
109413    +           %end;
109414    +           %if &dsid %then %let dsid = %sysfunc(close(&dsid));
109415    +           drop ub;
109416    +         run;
109418    +         proc datasets library=work nolist;
109419    +           delete class temp temp_missing;
109420    +         run;
109421    +         quit;
109423    +%mend EM_GENERATE_LABELVALUES;
109425    +%macro calcValidationCoarse(input, output, varmappings, resultsTable);
109428    +%mend calcValidationCoarse;
109431    +%macro EM_IBN_IntTargetTrans(inttgtvar,method,newlevels=binlevs);
109432    +/* macro for transforming interval target to binary */
109434    +   %if &method = CUTMEAN %then %do;
109435    +      proc sql noprint;
109436    +         %if %EM_FREQ ne %then %do;
109437    +            select sum(&inttgtvar * %EM_FREQ) / sum(%EM_FREQ)
109438    +         %end;
109439    +         %else %do;
109440    +            select mean(&inttgtvar)
109441    +         %end;
109442    +         into :ignbincut from &em_import_data;
109443    +      quit;
109444    +   %end;
109446    +   /* create binary target */
109447    +   data &EM_USER_NEWTRAIN;
109448    +      set &EM_IMPORT_DATA;
109449    +      %if &method = CUTUSER %then %do;
109450    +           %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
109451    +      %end;
109452    +      if &inttgtvar = . then &IGNBinTarget = .;
109453    +      else do;
109454    +         if &inttgtvar > &ignbincut then &IGNBinTarget=1;
109455    +         else &IGNBinTarget=0;
109456    +      end;
109457    +   run;
109459    +   /* Check that new target is actually binary */
109460    +   proc sql noprint;
109461    +      select distinct &IGNBINTarget into :bintv1 - from &EM_USER_NEWTRAIN where
109461   !+&IGNBinTarget ne .;
109462    +   quit;
109463    +   %global &newlevels;
109464    +   %let &newlevels=&sqlobs;
109466    +%mend EM_IBN_IntTargetTrans;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename trtemp;
NOTE: Fileref TRTEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data temp;
MPRINT(TRAIN):   set EMWS1.BINNING_VariableSet;
MPRINT(TRAIN):   where NAME =
MPRINT(TRAIN):  "bad";
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE NAME='bad';
NOTE: The data set WORK.TEMP has 1 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc dmdb data=EMWS1.Trans_TRAIN(where=(^missing(
MPRINT(EM_BINARY_TARGET):  bad
MPRINT(TRAIN):  ))) classout=EVENTOUT;
MPRINT(TRAIN):   target
MPRINT(EM_BINARY_TARGET):   bad
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   class
MPRINT(EM_BINARY_TARGET):   bad
MPRINT(TRAIN):  (DESC);
MPRINT(TRAIN):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS1.PART_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.09 seconds
      cpu time            0.09 seconds
      
NOTE: There were 2979 observations read from the data set EMWS1.REPL_TRAIN.
NOTE: There were 2979 observations read from the data set EMWS1.TRANS_TRAIN.
      WHERE not MISSING(bad);
NOTE: The data set WORK.EVENTOUT has 2 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.10 seconds
      cpu time            0.10 seconds
      

MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   dsid = open("EVENTOUT");
MPRINT(TRAIN):   if dsid>0 then do;
MPRINT(TRAIN):   levelnum = VARNUM(dsid, "LEVEL");
MPRINT(TRAIN):   if levelnum then do;
MPRINT(TRAIN):   if ^fetch(dsid) then call symput('TARGET_EVENT', strip(getvarc(dsid, 
levelnum)));
MPRINT(TRAIN):   if ^fetch(dsid) then call symput('TARGET_NONEVENT',strip(getvarc(dsid, 
levelnum)));
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   dsid=close(dsid);
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete eventout;
MPRINT(TRAIN):   run;

NOTE: Deleting WORK.EVENTOUT (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):   data EMWS1.BINNING_NEWTRAIN;
MPRINT(TRAIN):   set EMWS1.Trans_TRAIN;
MPRINT(TRAIN):   run;

NOTE: There were 2979 observations read from the data set EMWS1.PART_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.36 seconds
      cpu time            0.09 seconds
      
NOTE: There were 2979 observations read from the data set EMWS1.REPL_TRAIN.
NOTE: There were 2979 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set EMWS1.BINNING_NEWTRAIN has 2979 observations and 35 variables.
NOTE: DATA statement used (Total process time):
      real time           0.37 seconds
      cpu time            0.10 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc datasets library=EMWS1 nolist;
MPRINT(TRAIN):   delete BINNING_FINEDETAILDATA;
MPRINT(TRAIN):   run;

NOTE: Deleting EMWS1.BINNING_FINEDETAILDATA (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.18 seconds
      cpu time            0.07 seconds
      

MPRINT(TRAIN):   data tempvarnames;
MPRINT(TRAIN):   set EMWS1.BINNING_VariableSet;
MPRINT(TRAIN):   where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) 
and level ne 'UNARY';
MPRINT(TRAIN):   keep NAME LEVEL LABEL;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'))) and 
      (level not = 'UNARY');
NOTE: The data set WORK.TEMPVARNAMES has 12 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
MPRINT(TRAIN):   names NAME;
MPRINT(TRAIN):   prefix WOE_ GRP_ ;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 12 observations and 3 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=tempmapping;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 12 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=tempvarnames;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPVARNAMES has 12 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data tempmapping;
MPRINT(TRAIN):   merge tempmapping tempvarnames;
MPRINT(TRAIN):   by NAME;
MPRINT(TRAIN):   rename LEVEL=procLevel;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPMAPPING.
NOTE: There were 12 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 12 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_MAPPING_TABLE):  ;
MPRINT(EM_GENERATE_MAPPING_TABLE):   data EMWS1.BINNING_VARMAPPINGS(keep=_variable_ 
_grp_variable_ procLevel label);
MPRINT(EM_GENERATE_MAPPING_TABLE):   length _variable_ _grp_variable_ $32 procLevel $8;
MPRINT(EM_GENERATE_MAPPING_TABLE):   set tempmapping;
MPRINT(EM_GENERATE_MAPPING_TABLE):   label _variable_ = "Input Variable" _grp_variable_ = 
"Group Variable";
MPRINT(EM_GENERATE_MAPPING_TABLE):   _variable_ = NAME;
MPRINT(EM_GENERATE_MAPPING_TABLE):   _grp_variable_ = GRP;
MPRINT(EM_GENERATE_MAPPING_TABLE):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 12 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.37 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete tempImport tempScore;
MPRINT(TRAIN):   run;

NOTE: The file WORK.TEMPIMPORT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPSCORE (memtype=DATA) was not found, but appears on a DELETE statement.
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):   proc datasets library=EMWS1 nolist;
MPRINT(TRAIN):   delete BINNING_SPLITVALS;
MPRINT(TRAIN):   run;

NOTE: Deleting EMWS1.BINNING_SPLITVALS (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.10 seconds
      cpu time            0.10 seconds
      

MPRINT(EM_PRE_BINNING):   data tempvariableset;
MPRINT(EM_PRE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_PRE_BINNING):   where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) 
OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='INTERVAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or 
      ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 10 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 1 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Thu, Nov  5, 2015 02:09:06 PM,
      Last Modified=Thu, Nov  5, 2015 02:09:18 PM,
      Filename=C:\Users\bteric01\AppData\Local\Temp\SAS Temporary 
      Files\_TD3196_COB-IT-M12_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 8 records were written to the file MACFILE.
      The minimum record length was 19.
      The maximum record length was 71.
NOTE: There were 10 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
109471    +%macro intervalvars;
109472    +LOG_REP_clage LOG_REP_clno LOG_REP_debtinc LOG_REP_delinq LOG_REP_derog
109473    +LOG_REP_loan LOG_REP_mortdue LOG_REP_ninq LOG_REP_value LOG_REP_yoj
109474    +%mend intervalvars;
109475    +%global num_intvars;
109476    +%let num_intvars = 10 ;
109477    +%global num_intvars;
109478    +%let num_intvars = 10 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_PRE_BINNING):  ;
MPRINT(EM_PRE_BINNING):   proc dmdb data=EMWS1.BINNING_NEWTRAIN classout=_CLASSOUT maxlevel=5;
MPRINT(EM_PRE_BINNING):   class
MPRINT(INTERVALVARS):   LOG_REP_clage LOG_REP_clno LOG_REP_debtinc LOG_REP_delinq 
LOG_REP_derog LOG_REP_loan LOG_REP_mortdue LOG_REP_ninq LOG_REP_value LOG_REP_yoj
MPRINT(EM_PRE_BINNING):  ;
MPRINT(EM_PRE_BINNING):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set WORK._CLASSOUT has 50 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_PRE_BINNING):   proc freq data=_CLASSOUT order=DATA noprint;
MPRINT(EM_PRE_BINNING):   table NAME / OUT= _COUNT(where=(COUNT<5));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 50 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._COUNT has 0 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   set _COUNT;
MPRINT(EM_PRE_BINNING):   call symput('_INTBINS',symget('_INTBINS') !! ' ' !! 
ktrim(kleft(NAME)));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 0 observations read from the data set WORK._COUNT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   proc sort data=_CLASSOUT;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 50 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 50 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ 
RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
MPRINT(EM_PRE_BINNING):   var NRAW;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 50 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._OUT has 10 observations and 6 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   dsid = open('_OUT');
MPRINT(EM_PRE_BINNING):   if dsid then do;
MPRINT(EM_PRE_BINNING):   call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, 
best12.))));
MPRINT(EM_PRE_BINNING):   csid = close(dsid);
MPRINT(EM_PRE_BINNING):   end;
MPRINT(EM_PRE_BINNING):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   data _INTMID;
MPRINT(EM_PRE_BINNING):   set _OUT;
MPRINT(EM_PRE_BINNING):   keep VARIABLE _MIDPOINT1--_MIDPOINT5 ;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._OUT.
NOTE: The data set WORK._INTMID has 10 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   label procLevel = "Level for Interactive";
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 12 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename temp catalog 'sashelp.emapps.quantile_binning.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMAPPS.QUANTILE_BINNING.SOURCE.
109480    +%macro em_apps_quantile_binning(input, vartable, numbins, binmappings, binningCode,
109480   !+codeMappings=, precision=0.01, dropOriginal=N, IncludeTarget=N);
109482    +  /* initialize binmappings table */
109483    +  data &BINMAPPINGS;
109484    +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
109485    +  run;
109489    +  %if &IncludeTarget=N %then %do;
109490    +   /* process only INTERVAL INPUTS */
109491    +  data tempvars;
109492    +    set &vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
109493    +  run;
109494    +  %end;
109496    +  %if &IncludeTarget=Y %then %do;
109497    +   /* process both INTERVAL INPUTS and INTERVAL TARGETS*/
109498    +  data tempvars;
109499    +    set &vartable(where=((ROLE="INPUT" AND LEVEL="INTERVAL") or (ROLE="TARGET" AND
109499   !+LEVEL="INTERVAL")));
109500    +  run;
109501    +  %end;
109503    +  /* retrieve the name of interval inputs to bin */
109504    +  filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
109505    +  %include tempopen;
109506    +  filename tempopen;
109508    +  %let intvars = ;
109509    +  %global num_intvars;
109510    +  %let num_intvars = 0;
109511    +  %em_varmacro(name=intvars, metadata=tempvars, key=NAME, nummacro=num_intvars);
109513    +  /* retrieve the name of frequency variable if it exists */
109514    +  %let em_bin_freq = ;
109515    +  %let choice = ROLE="FREQ";
109516    +  %let fdsid = %sysfunc(open(&vartable(where=(&choice))));
109517    +  %if &fdsid %then %do;
109518    +    %let fvarnum = %sysfunc(VARNUM(&fdsid, NAME));
109519    +    %let fobs = %sysfunc(fetch(&fdsid));
109520    +    %do %while(&fobs=0);
109521    +       %let em_bin_freq = %sysfunc(getvarc(&fdsid, &fvarnum));
109522    +       %let fobs = %sysfunc(fetch(&fdsid));
109523    +    %end;
109524    +  %end;
109525    +  %if &fdsid >0 %then %let fdsid = %sysfunc(close(&fdsid));
109527    +  /* process all inputs */
109528    +  %if &num_intvars > 0 %then %do;
109530    +    /* Computing quantile binning of interval inputs */
109531    +    %let numbin = %eval(&NUMBINS - 1);
109532    +    %let optstr=;
109533    +    %do i=1 %to &numbin;
109534    +       %let optstr = &optstr %sysevalf(&i*100/&&NUMBINS);
109535    +    %end;
109537    +    data tempInt / view = tempInt;
109538    +      set &input(keep= %intvars
109539    +      %if &em_bin_freq ne %then %do;
109540    +        &em_bin_freq
109541    +      %end;
109542    +      );
109543    +    run;
109545    +    proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=&optstr;
109546    +       var %intvars;
109547    +       %if &em_bin_freq ne %then %do;
109548    +          freq &em_bin_freq / notrunc;
109549    +       %end;
109550    +    run;
109552    +    proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
109553    +    run;
109555    +    /* generate unique BIN_xxx names for all inputs processed */
109556    +    proc dmdb data=tempvars outtable=tempmapping nameserver;
109557    +     names NAME;
109558    +     prefix BIN_ ;
109559    +    run;
109561    +    proc sort data=tempmapping(keep=NAME bin); by NAME; run;
109562    +    proc sort data=work.pctdata; by _NAME_; run;
109563    +    %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
109564    +      proc sort data=&codemappings nodupkey out=tempcodemappings(keep= codeVar
109564   !+variable) ; by codeVar; run;
109565    +    %end;
109567    +    data tempbins;
109568    +      length display_var $32;
109569    +      merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar))
109570    +      %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do
109570   !+;
109571    +         tempcodemappings(rename=(codeVar=_name_ variable=display_var))
109572    +      %end;
109573    +      ;
109574    +      by _NAME_;
109575    +      if _a;
109576    +      if missing(display_var) then display_var = _NAME_;
109577    +    run;
109579    +    /* generate BINMAPPINGS dataset and binningCode file*/
109580    +    data _null_;
109581    +      FILE &binningCode;
109582    +      set tempbins end=eof;
109583    +      length string $200;
109584    +      by _NAME_;
109586    +      if _n_=1 then do;
109587    +        put "&EM_CODEBAR;";
109588    +        %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
109589    +        put "* &note;";
109590    +        put "&EM_CODEBAR;";
109592    +        call execute(" data &BINMAPPINGS; ");
109593    +        call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
109594    +      end;
109596    +      %do i=1 %to %eval(&numbins-1);
109597    +       %if &i eq 1 %then %do;
109598    +         %let colname = COL&i;
109599    +         %let binvalnum = 1;
109600    +         LB = .;
109601    +         UB = round(&colname, &precision);
109602    +         bin=&binvalnum;
109604    +         call execute("name='"||strip(_NAME_)||"'; ");
109605    +         call execute("bin_name='"||strip(binVar)||"'; ");
109606    +         call execute("bin='"||strip(bin)||"';");
109607    +         call execute("LB=.;");
109608    +         call execute("UB="||UB||";");
109609    +         call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
109610    +         call execute("output;");
109612    +         string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
109614    +         put string;
109615    +         string = "else do;";
109616    +         put string;
109618    +         string= "  if "||strip(_name_)||" < "||strip(UB)||" then
109618   !+"||strip(binVar)||"="||strip(bin)||";";
109619    +         put string;
109622    +       %end;
109623    +       %else %do;
109624    +         %let colname = COL&i;
109625    +         %let lbnum = %sysevalf(&i-1);
109626    +         %let lbcol = COL&lbnum;
109627    +         UB = round(&colname, &precision);
109628    +         LB = round(&lbcol, &precision);
109629    +         if UB ne LB then do;
109630    +           bin=bin+1;
109632    +           call execute("name='"||strip(_NAME_)||"'; ");
109633    +           call execute("bin_name='"||strip(binVar)||"'; ");
109634    +           call execute("bin='"||strip(bin)||"';");
109635    +           call execute("LB="||LB||";");
109636    +           call execute("UB="||UB||";");
109637    +           call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" <
109637   !+ "||strip(UB)||"';");
109638    +           call execute("output;");
109640    +           string= "  else if "||strip(_name_)||" < "||strip(UB)||" then
109640   !+"||strip(binVar)||"="||strip(bin)||";";
109641    +           put string;
109643    +         end;
109644    +       %end;
109645    +      %end;
109646    +      %let binvalnum = %sysevalf(&binvalnum + 1);
109647    +      bin=bin+1;
109648    +      LB = round(&colname, &precision);
109649    +      UB = .;
109651    +      call execute("name='"||strip(_NAME_)||"'; ");
109652    +      call execute("bin_name = '"||strip(binVar)||"'; ");
109653    +      call execute("bin='"||strip(bin)||"';");
109654    +      call execute("UB=.;");
109655    +      call execute("LB="||LB||";");
109656    +      call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
109657    +      call execute("output;");
109659    +      string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then
109659   !+"||strip(binVar)||"="||strip(bin)||";";
109660    +      put string;
109661    +      string="end;";
109662    +      put string;
109664    +      if eof then do;
109665    +        call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
109666    +        call execute("  if LB=UB then delete;");
109667    +        call execute("run;");
109668    +      end;
109670    +    run;
109672    +    /* drop original inputs */
109673    +    %if &dropOriginal=Y %then %do;
109674    +      data _null_;
109675    +        set work.tempvars end=eof;
109676    +        FILE &binningCode MOD;
109677    +        length string $200;
109679    +        if _n_=1 then do;
109680    +          put "drop";
109681    +        end;
109682    +        string = " "||strip(name);
109683    +        put string;
109685    +        if eof then do;
109686    +          put ";";
109687    +        end;
109688    +      run;
109689    +    %end;
109691    +    proc datasets library=work nolist;
109692    +      delete pctdata tempmapping tempbins tempInt;
109693    +    run;
109694    +    quit;
109695    +  %end;
109697    +  proc datasets library=work nolist;
109698    +    delete tempvars;
109699    +  run;
109700    +  quit;
109702    +%mend em_apps_quantile_binning;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   filename X 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\BINNINGCODE.
sas";
MPRINT(EM_QUANTILE_BINNING):   data work.vartable;
MPRINT(EM_QUANTILE_BINNING):   set work._intmid;
MPRINT(EM_QUANTILE_BINNING):   level = "INTERVAL";
MPRINT(EM_QUANTILE_BINNING):   role = "INPUT";
MPRINT(EM_QUANTILE_BINNING):   rename variable=name;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._INTMID.
NOTE: The data set WORK.VARTABLE has 10 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Variable NAME is uninitialized.
NOTE: Variable BIN_NAME is uninitialized.
NOTE: Variable LB is uninitialized.
NOTE: Variable UB is uninitialized.
NOTE: Variable BIN is uninitialized.
NOTE: Variable EM_BIN_LABEL is uninitialized.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 1 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.vartable(where=(ROLE="INPUT" AND 
LEVEL="INTERVAL"));
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK.VARTABLE.
      WHERE (ROLE='INPUT') and (LEVEL='INTERVAL');
NOTE: The data set WORK.TEMPVARS has 10 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen catalog 
'sashelp.emutil.em_varmacro.source';
NOTE: %INCLUDE (level 1) file TEMPOPEN is file SASHELP.EMUTIL.EM_VARMACRO.SOURCE.
109706    +
109707    +%macro em_varMacro(name=emMacro, metadata=, where=, key=NAME, nummacro=);
109708    +
109709    +   filename macFile catalog 'work.emutil.macro.source';
109710    +   %let _METAOBS = 0;
109711    +
109712    +   %if (%sysfunc(exist(&metadata))<1 and %sysfunc(exist(&metadata, VIEW))<1)
109713    +                   or (&metadata eq ) %then %do;
109714    +       %put * No metadata data set defined;
109715    +       %goto doend;
109716    +   %end;
109717    +
109718    +   data _null_;
109719    +      length _STRING_ $80;
109720    +      retain _STRING_;
109721    +      set &metadata end=eof;
109722    +      file macFile;
109723    +      %if %nrbquote(&where) ne %then %do;
109724    +          %let whereClause = where (%nrbquote(&where));
109725    +          %unquote(&whereClause);
109726    +      %end;
109727    +      if _N_=1 then do;
109728    +         string = "%"!!"macro &name;";
109729    +         put string;
109730    +      end;
109731    +      if (length(_STRING_) + length(trim(&key))+ 1 < 80) then do;
109732    +         _STRING_ = trim(_STRING_)!!' '!!trim(&key);
109733    +         if eof then do;
109734    +            put _STRING_;
109735    +            string = "%"!!"mend &name;";
109736    +            put string;
109737    +            %if (&nummacro ne ) %then %do;
109738    +                string = strip(put(_N_, best.));
109739    +                put "%" "global &nummacro;";
109740    +                put "%" "let &nummacro = " string ";";
109741    +                call symput('_METAOBS', string);
109742    +            %end;
109743    +         end;
109744    +      end;
109745    +      else do;
109746    +         put _STRING_;
109747    +         _string_ = TRIM(&key);
109748    +         if eof then do;
109749    +            put _STRING_;
109750    +            string = "%"!!"mend &name;";
109751    +            put string;
109752    +        end;
109753    +      end;
109754    +      if eof then do;
109755    +         string = strip(put(_N_, best.));
109756    +         call symput('_METAOBS', string);
109757    +         %if (&nummacro ne ) %then %do;
109758    +             put "%" "global &nummacro;";
109759    +             put "%" "let &nummacro = " string ";";
109760    +         %end;
109761    +      end;
109762    +   run;
109763    +
109764    +   %doend:
109765    +   %if ^&_METAOBS %then %do;
109766    +       data _null_;
109767    +          file macFile;
109768    +          put "%" "macro &name;";
109769    +          put "%" "mend &name;";
109770    +          %if (&nummacro ne ) %then %do;
109771    +              put "%" "global &nummacro;";
109772    +              put "%" "let &nummacro = 0;";
109773    +          %end;
109774    +      run;
109775    +   %end;
109776    +   %inc macFile;
109777    +   filename macFile;
109778    +%mend em_varMacro;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen;
NOTE: Fileref TEMPOPEN has been deassigned.
MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_;
MPRINT(EM_VARMACRO):   set tempvars end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 1 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Thu, Nov  5, 2015 02:09:06 PM,
      Last Modified=Thu, Nov  5, 2015 02:10:42 PM,
      Filename=C:\Users\bteric01\AppData\Local\Temp\SAS Temporary 
      Files\_TD3196_COB-IT-M12_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 8 records were written to the file MACFILE.
      The minimum record length was 14.
      The maximum record length was 71.
NOTE: There were 10 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
109779    +%macro intvars;
109780    +LOG_REP_clage LOG_REP_clno LOG_REP_debtinc LOG_REP_delinq LOG_REP_derog
109781    +LOG_REP_loan LOG_REP_mortdue LOG_REP_ninq LOG_REP_value LOG_REP_yoj
109782    +%mend intvars;
109783    +%global num_intvars;
109784    +%let num_intvars = 10 ;
109785    +%global num_intvars;
109786    +%let num_intvars = 10 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   data tempInt / view = tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN(keep
MPRINT(EM_APPS_QUANTILE_BINNING):  = LOG_REP_clage LOG_REP_clno LOG_REP_debtinc LOG_REP_delinq 
LOG_REP_derog LOG_REP_loan LOG_REP_mortdue LOG_REP_ninq LOG_REP_value LOG_REP_yoj );
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: DATA STEP view saved on file WORK.TEMPINT.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc stdize data=work.tempInt outstat=work.pctdata 
out=_null_ pctlpts=25 50 75;
MPRINT(EM_APPS_QUANTILE_BINNING):   var
MPRINT(INTVARS):   LOG_REP_clage LOG_REP_clno LOG_REP_debtinc LOG_REP_delinq LOG_REP_derog 
LOG_REP_loan LOG_REP_mortdue LOG_REP_ninq LOG_REP_value LOG_REP_yoj
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: View WORK.TEMPINT.VIEW used (Total process time):
      real time           0.20 seconds
      cpu time            0.20 seconds
      
NOTE: There were 2979 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: There were 2979 observations read from the data set WORK.TEMPINT.
NOTE: The data set WORK.PCTDATA has 11 observations and 11 variables.
NOTE: PROCEDURE STDIZE used (Total process time):
      real time           0.23 seconds
      cpu time            0.23 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc transpose data=work.pctdata(where=(_type_=:'P')) 
out=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 3 observations read from the data set WORK.PCTDATA.
      WHERE _type_=:'P';
NOTE: The data set WORK.PCTDATA has 10 observations and 5 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc dmdb data=tempvars outtable=tempmapping nameserver;
MPRINT(EM_APPS_QUANTILE_BINNING):   names NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   prefix BIN_ ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPVARS.
NOTE: The data set WORK.TEMPMAPPING has 10 observations and 2 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=tempmapping(keep=NAME bin);
MPRINT(EM_APPS_QUANTILE_BINNING):   by NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 10 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK.PCTDATA.
NOTE: The data set WORK.PCTDATA has 10 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempbins;
MPRINT(EM_APPS_QUANTILE_BINNING):   length display_var $32;
MPRINT(EM_APPS_QUANTILE_BINNING):   merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ 
bin=binVar)) ;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _a;
MPRINT(EM_APPS_QUANTILE_BINNING):   if missing(display_var) then display_var = _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

WARNING: Multiple lengths were specified for the BY variable _NAME_ by input data sets. This 
         might cause unexpected results.
NOTE: There were 10 observations read from the data set WORK.PCTDATA.
NOTE: There were 10 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPBINS has 10 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X;
MPRINT(EM_APPS_QUANTILE_BINNING):   set tempbins end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put 
"*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "* Generating Bins for interval variables;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put 
"*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute(" data EMWS1.BINNING_BINMAPPINGS; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("   length name bin_name $32 LB UB 8 
EM_BIN_LABEL BIN $200;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_var)||" < 
"||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "if "||strip(_name_)||" eq . then 
"||strip(binVar)||"= .;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "else do;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  if "||strip(_name_)||" < "||strip(UB)||" then 
"||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= 
"||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" 
then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= 
"||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" 
then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name = '"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= 
"||strip(LB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" >= "||strip(LB)||" 
then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string="end;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if NAME='' and BIN_NAME='' and BIN='' then 
delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if LB=UB then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("run;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Numeric values have been converted to character values at the places given by: 
      (Line):(Column).
      216:110   222:129   225:166   254:48    254:89    283:110   286:111   289:122   292:139
      292:185   303:44    303:85    337:110   340:111   343:122   346:139   346:185   357:44
      357:85    388:108   394:129   397:167   407:45    407:86    
NOTE: The file X is:
      
      Filename=C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNIN
      G\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=05Nov2015:14:10:42,
      Create Time=05Nov2015:05:45:02

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_clage';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_clage';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 4.76;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_clage < 4.76';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_clage';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_clage';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 4.76;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 5.17;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='4.76 <= LOG_REP_clage < 5.17';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_clage';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_clage';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 5.17;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 5.45;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='5.17 <= LOG_REP_clage < 5.45';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_clage';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_clage';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 5.45;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_clage >= 5.45';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_clno';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_clno';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2.71;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_clno < 2.71';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_clno';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_clno';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2.71;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.04;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='2.71 <= LOG_REP_clno < 3.04';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_clno';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_clno';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.04;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.3;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='3.04 <= LOG_REP_clno < 3.3';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_clno';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_clno';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.3;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_clno >= 3.3';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_debtinc';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_debtinc';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.4;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_debtinc < 3.4';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_debtinc';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_debtinc';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.4;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.58;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='3.4 <= LOG_REP_debtinc < 3.58';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_debtinc';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_debtinc';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.58;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.69;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='3.58 <= LOG_REP_debtinc < 3.69';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_debtinc';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_debtinc';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.69;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_debtinc >= 3.69';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_delinq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_delinq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_delinq < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_delinq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_delinq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_delinq >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_derog';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_derog';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_derog < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_derog';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_derog';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_derog >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_loan';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_loan';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 9.31;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_loan < 9.31';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_loan';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_loan';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 9.31;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 9.69;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='9.31 <= LOG_REP_loan < 9.69';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_loan';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_loan';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 9.69;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 10.05;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='9.69 <= LOG_REP_loan < 10.05';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_loan';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_loan';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 10.05;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_loan >= 10.05';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_mortdue';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_mortdue';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 10.75;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_mortdue < 10.75';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_mortdue';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_mortdue';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 10.75;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.08;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='10.75 <= LOG_REP_mortdue < 11.08';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_mortdue';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_mortdue';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.08;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.45;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='11.08 <= LOG_REP_mortdue < 11.45';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_mortdue';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_mortdue';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.45;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_mortdue >= 11.45';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_ninq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_ninq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_ninq < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_ninq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_ninq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0.69;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='0 <= LOG_REP_ninq < 0.69';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_ninq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_ninq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0.69;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1.1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='0.69 <= LOG_REP_ninq < 1.1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_ninq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_ninq';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1.1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_ninq >= 1.1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_value';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_value';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_value < 11.1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_value';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_value';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.1;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.4;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='11.1 <= LOG_REP_value < 11.4';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_value';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_value';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.4;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.71;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='11.4 <= LOG_REP_value < 11.71';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_value';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_value';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.71;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_value >= 11.71';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_yoj';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_yoj';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1.39;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_yoj < 1.39';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_yoj';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_yoj';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1.39;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2.08;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1.39 <= LOG_REP_yoj < 2.08';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_yoj';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_REP_yoj';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2.08;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2.64;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='2.08 <= LOG_REP_yoj < 2.64';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_REP_yoj';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_REP_yoj';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2.64;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_REP_yoj >= 2.64';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   if NAME='' and BIN_NAME='' and BIN='' then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   if LB=UB then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;
NOTE: 69 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 63.
NOTE: There were 10 observations read from the data set WORK.TEMPBINS.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

NOTE: CALL EXECUTE generated line.
1         +  data EMWS1.BINNING_BINMAPPINGS;
2         +    length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):  32 LB UB EM_BIN_LABEL BIN200
3         + name='LOG_REP_clage';
4         + bin_name='BIN_LOG_REP_clage';
5         + bin='1';
6         + LB=.;
7         + UB=        4.76;
8         + EM_BIN_LABEL='LOG_REP_clage < 4.76';
9         + output;
10        + name='LOG_REP_clage';
11        + bin_name='BIN_LOG_REP_clage';
12        + bin='2';
13        + LB=        4.76;
14        + UB=        5.17;
15        + EM_BIN_LABEL='4.76 <= LOG_REP_clage < 5.17';
16        + output;
17        + name='LOG_REP_clage';
18        + bin_name='BIN_LOG_REP_clage';
19        + bin='3';
20        + LB=        5.17;
21        + UB=        5.45;
22        + EM_BIN_LABEL='5.17 <= LOG_REP_clage < 5.45';
23        + output;
24        + name='LOG_REP_clage';
25        + bin_name = 'BIN_LOG_REP_clage';
26        + bin='4';
27        + UB=.;
28        + LB=        5.45;
29        + EM_BIN_LABEL='LOG_REP_clage >= 5.45';
30        + output;
31        + name='LOG_REP_clno';
32        + bin_name='BIN_LOG_REP_clno';
33        + bin='1';
34        + LB=.;
35        + UB=        2.71;
36        + EM_BIN_LABEL='LOG_REP_clno < 2.71';
37        + output;
38        + name='LOG_REP_clno';
39        + bin_name='BIN_LOG_REP_clno';
40        + bin='2';
41        + LB=        2.71;
42        + UB=        3.04;
43        + EM_BIN_LABEL='2.71 <= LOG_REP_clno < 3.04';
44        + output;
45        + name='LOG_REP_clno';
46        + bin_name='BIN_LOG_REP_clno';
47        + bin='3';
48        + LB=        3.04;
49        + UB=         3.3;
50        + EM_BIN_LABEL='3.04 <= LOG_REP_clno < 3.3';
51        + output;
52        + name='LOG_REP_clno';
53        + bin_name = 'BIN_LOG_REP_clno';
54        + bin='4';
55        + UB=.;
56        + LB=         3.3;
57        + EM_BIN_LABEL='LOG_REP_clno >= 3.3';
58        + output;
59        + name='LOG_REP_debtinc';
60        + bin_name='BIN_LOG_REP_debtinc';
61        + bin='1';
62        + LB=.;
63        + UB=         3.4;
64        + EM_BIN_LABEL='LOG_REP_debtinc < 3.4';
65        + output;
66        + name='LOG_REP_debtinc';
67        + bin_name='BIN_LOG_REP_debtinc';
68        + bin='2';
69        + LB=         3.4;
70        + UB=        3.58;
71        + EM_BIN_LABEL='3.4 <= LOG_REP_debtinc < 3.58';
72        + output;
73        + name='LOG_REP_debtinc';
74        + bin_name='BIN_LOG_REP_debtinc';
75        + bin='3';
76        + LB=        3.58;
77        + UB=        3.69;
78        + EM_BIN_LABEL='3.58 <= LOG_REP_debtinc < 3.69';
79        + output;
80        + name='LOG_REP_debtinc';
81        + bin_name = 'BIN_LOG_REP_debtinc';
82        + bin='4';
83        + UB=.;
84        + LB=        3.69;
85        + EM_BIN_LABEL='LOG_REP_debtinc >= 3.69';
86        + output;
87        + name='LOG_REP_delinq';
88        + bin_name='BIN_LOG_REP_delinq';
89        + bin='1';
90        + LB=.;
91        + UB=           0;
92        + EM_BIN_LABEL='LOG_REP_delinq < 0';
93        + output;
94        + name='LOG_REP_delinq';
95        + bin_name = 'BIN_LOG_REP_delinq';
96        + bin='2';
97        + UB=.;
98        + LB=           0;
99        + EM_BIN_LABEL='LOG_REP_delinq >= 0';
100       + output;
101       + name='LOG_REP_derog';
102       + bin_name='BIN_LOG_REP_derog';
103       + bin='1';
104       + LB=.;
105       + UB=           0;
106       + EM_BIN_LABEL='LOG_REP_derog < 0';
107       + output;
108       + name='LOG_REP_derog';
109       + bin_name = 'BIN_LOG_REP_derog';
110       + bin='2';
111       + UB=.;
112       + LB=           0;
113       + EM_BIN_LABEL='LOG_REP_derog >= 0';
114       + output;
115       + name='LOG_REP_loan';
116       + bin_name='BIN_LOG_REP_loan';
117       + bin='1';
118       + LB=.;
119       + UB=        9.31;
120       + EM_BIN_LABEL='LOG_REP_loan < 9.31';
121       + output;
122       + name='LOG_REP_loan';
123       + bin_name='BIN_LOG_REP_loan';
124       + bin='2';
125       + LB=        9.31;
126       + UB=        9.69;
127       + EM_BIN_LABEL='9.31 <= LOG_REP_loan < 9.69';
128       + output;
129       + name='LOG_REP_loan';
130       + bin_name='BIN_LOG_REP_loan';
131       + bin='3';
132       + LB=        9.69;
133       + UB=       10.05;
134       + EM_BIN_LABEL='9.69 <= LOG_REP_loan < 10.05';
135       + output;
136       + name='LOG_REP_loan';
137       + bin_name = 'BIN_LOG_REP_loan';
138       + bin='4';
139       + UB=.;
140       + LB=       10.05;
141       + EM_BIN_LABEL='LOG_REP_loan >= 10.05';
142       + output;
143       + name='LOG_REP_mortdue';
144       + bin_name='BIN_LOG_REP_mortdue';
145       + bin='1';
146       + LB=.;
147       + UB=       10.75;
148       + EM_BIN_LABEL='LOG_REP_mortdue < 10.75';
149       + output;
150       + name='LOG_REP_mortdue';
151       + bin_name='BIN_LOG_REP_mortdue';
152       + bin='2';
153       + LB=       10.75;
154       + UB=       11.08;
155       + EM_BIN_LABEL='10.75 <= LOG_REP_mortdue < 11.08';
156       + output;
157       + name='LOG_REP_mortdue';
158       + bin_name='BIN_LOG_REP_mortdue';
159       + bin='3';
160       + LB=       11.08;
161       + UB=       11.45;
162       + EM_BIN_LABEL='11.08 <= LOG_REP_mortdue < 11.45';
163       + output;
164       + name='LOG_REP_mortdue';
165       + bin_name = 'BIN_LOG_REP_mortdue';
166       + bin='4';
167       + UB=.;
168       + LB=       11.45;
169       + EM_BIN_LABEL='LOG_REP_mortdue >= 11.45';
170       + output;
171       + name='LOG_REP_ninq';
172       + bin_name='BIN_LOG_REP_ninq';
173       + bin='1';
174       + LB=.;
175       + UB=           0;
176       + EM_BIN_LABEL='LOG_REP_ninq < 0';
177       + output;
178       + name='LOG_REP_ninq';
179       + bin_name='BIN_LOG_REP_ninq';
180       + bin='2';
181       + LB=           0;
182       + UB=        0.69;
183       + EM_BIN_LABEL='0 <= LOG_REP_ninq < 0.69';
184       + output;
185       + name='LOG_REP_ninq';
186       + bin_name='BIN_LOG_REP_ninq';
187       + bin='3';
188       + LB=        0.69;
189       + UB=         1.1;
190       + EM_BIN_LABEL='0.69 <= LOG_REP_ninq < 1.1';
191       + output;
192       + name='LOG_REP_ninq';
193       + bin_name = 'BIN_LOG_REP_ninq';
194       + bin='4';
195       + UB=.;
196       + LB=         1.1;
197       + EM_BIN_LABEL='LOG_REP_ninq >= 1.1';
198       + output;
199       + name='LOG_REP_value';
200       + bin_name='BIN_LOG_REP_value';
201       + bin='1';
202       + LB=.;
203       + UB=        11.1;
204       + EM_BIN_LABEL='LOG_REP_value < 11.1';
205       + output;
206       + name='LOG_REP_value';
207       + bin_name='BIN_LOG_REP_value';
208       + bin='2';
209       + LB=        11.1;
210       + UB=        11.4;
211       + EM_BIN_LABEL='11.1 <= LOG_REP_value < 11.4';
212       + output;
213       + name='LOG_REP_value';
214       + bin_name='BIN_LOG_REP_value';
215       + bin='3';
216       + LB=        11.4;
217       + UB=       11.71;
218       + EM_BIN_LABEL='11.4 <= LOG_REP_value < 11.71';
219       + output;
220       + name='LOG_REP_value';
221       + bin_name = 'BIN_LOG_REP_value';
222       + bin='4';
223       + UB=.;
224       + LB=       11.71;
225       + EM_BIN_LABEL='LOG_REP_value >= 11.71';
226       + output;
227       + name='LOG_REP_yoj';
228       + bin_name='BIN_LOG_REP_yoj';
229       + bin='1';
230       + LB=.;
231       + UB=        1.39;
232       + EM_BIN_LABEL='LOG_REP_yoj < 1.39';
233       + output;
234       + name='LOG_REP_yoj';
235       + bin_name='BIN_LOG_REP_yoj';
236       + bin='2';
237       + LB=        1.39;
238       + UB=        2.08;
239       + EM_BIN_LABEL='1.39 <= LOG_REP_yoj < 2.08';
240       + output;
241       + name='LOG_REP_yoj';
242       + bin_name='BIN_LOG_REP_yoj';
243       + bin='3';
244       + LB=        2.08;
245       + UB=        2.64;
246       + EM_BIN_LABEL='2.08 <= LOG_REP_yoj < 2.64';
247       + output;
248       + name='LOG_REP_yoj';
249       + bin_name = 'BIN_LOG_REP_yoj';
250       + bin='4';
251       + UB=.;
252       + LB=        2.64;
253       + EM_BIN_LABEL='LOG_REP_yoj >= 2.64';
254       + output;
255       +   if NAME='' and BIN_NAME='' and BIN='' then delete;
256       +   if LB=UB then delete;
257       + run;

NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 36 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.tempvars end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X MOD;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "drop";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = " "||strip(name);
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put ";";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file X is:
      
      Filename=C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNIN
      G\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=2952,
      Last Modified=05Nov2015:14:10:43,
      Create Time=05Nov2015:05:45:02

NOTE: 12 records were written to the file X.
      The minimum record length was 1.
      The maximum record length was 15.
NOTE: There were 10 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete pctdata tempmapping tempbins tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file WORK.TEMPINT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.PCTDATA (memtype=DATA).
NOTE: Deleting WORK.TEMPMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPBINS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.TEMPVARS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   by name lb;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 36 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   length display_var $32 grp $8;
MPRINT(EM_QUANTILE_BINNING):   display_var = name;
MPRINT(EM_QUANTILE_BINNING):   GRP = BIN + 1;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: 
      (Line):(Column).
      76:92   
NOTE: Numeric values have been converted to character values at the places given by: 
      (Line):(Column).
      76:96   
NOTE: There were 36 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 36 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedmapping 
nodupkey;
MPRINT(EM_QUANTILE_BINNING):   by NAME;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: 26 observations with duplicate key values were deleted.
NOTE: The data set WORK.SORTEDMAPPING has 10 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 1 observations and 0 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   set sortedmapping;
MPRINT(EM_QUANTILE_BINNING):   GRP="1";
MPRINT(EM_QUANTILE_BINNING):   bin="Missing";
MPRINT(EM_QUANTILE_BINNING):   _split_value_ = "Missing";
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK.SORTEDMAPPING.
NOTE: The data set WORK.TEMPMISSVALUES has 10 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\BINNINGCODE.
sas";
MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINDATA;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN;
NOTE: %INCLUDE (level 1) file X is file 
      C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\BINNING
      CODE.sas.
109787    +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
109788    +* Generating Bins for interval variables;
MPRINT(EM_QUANTILE_BINNING):   * Generating Bins for interval variables;
109789    +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
109790    +if LOG_REP_clage eq . then BIN_LOG_REP_clage= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_clage eq . then BIN_LOG_REP_clage= .;
109791    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109792    +if LOG_REP_clage < 4.76 then BIN_LOG_REP_clage=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_clage < 4.76 then BIN_LOG_REP_clage=1;
109793    +else if LOG_REP_clage < 5.17 then BIN_LOG_REP_clage=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_clage < 5.17 then BIN_LOG_REP_clage=2;
109794    +else if LOG_REP_clage < 5.45 then BIN_LOG_REP_clage=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_clage < 5.45 then BIN_LOG_REP_clage=3;
109795    +else if LOG_REP_clage >= 5.45 then BIN_LOG_REP_clage=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_clage >= 5.45 then BIN_LOG_REP_clage=4;
109796    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109797    +if LOG_REP_clno eq . then BIN_LOG_REP_clno= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_clno eq . then BIN_LOG_REP_clno= .;
109798    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109799    +if LOG_REP_clno < 2.71 then BIN_LOG_REP_clno=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_clno < 2.71 then BIN_LOG_REP_clno=1;
109800    +else if LOG_REP_clno < 3.04 then BIN_LOG_REP_clno=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_clno < 3.04 then BIN_LOG_REP_clno=2;
109801    +else if LOG_REP_clno < 3.3 then BIN_LOG_REP_clno=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_clno < 3.3 then BIN_LOG_REP_clno=3;
109802    +else if LOG_REP_clno >= 3.3 then BIN_LOG_REP_clno=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_clno >= 3.3 then BIN_LOG_REP_clno=4;
109803    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109804    +if LOG_REP_debtinc eq . then BIN_LOG_REP_debtinc= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_debtinc eq . then BIN_LOG_REP_debtinc= .;
109805    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109806    +if LOG_REP_debtinc < 3.4 then BIN_LOG_REP_debtinc=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_debtinc < 3.4 then BIN_LOG_REP_debtinc=1;
109807    +else if LOG_REP_debtinc < 3.58 then BIN_LOG_REP_debtinc=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_debtinc < 3.58 then BIN_LOG_REP_debtinc=2;
109808    +else if LOG_REP_debtinc < 3.69 then BIN_LOG_REP_debtinc=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_debtinc < 3.69 then BIN_LOG_REP_debtinc=3;
109809    +else if LOG_REP_debtinc >= 3.69 then BIN_LOG_REP_debtinc=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_debtinc >= 3.69 then BIN_LOG_REP_debtinc=4;
109810    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109811    +if LOG_REP_delinq eq . then BIN_LOG_REP_delinq= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_delinq eq . then BIN_LOG_REP_delinq= .;
109812    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109813    +if LOG_REP_delinq < 0 then BIN_LOG_REP_delinq=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_delinq < 0 then BIN_LOG_REP_delinq=1;
109814    +else if LOG_REP_delinq >= 0 then BIN_LOG_REP_delinq=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_delinq >= 0 then BIN_LOG_REP_delinq=2;
109815    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109816    +if LOG_REP_derog eq . then BIN_LOG_REP_derog= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_derog eq . then BIN_LOG_REP_derog= .;
109817    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109818    +if LOG_REP_derog < 0 then BIN_LOG_REP_derog=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_derog < 0 then BIN_LOG_REP_derog=1;
109819    +else if LOG_REP_derog >= 0 then BIN_LOG_REP_derog=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_derog >= 0 then BIN_LOG_REP_derog=2;
109820    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109821    +if LOG_REP_loan eq . then BIN_LOG_REP_loan= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_loan eq . then BIN_LOG_REP_loan= .;
109822    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109823    +if LOG_REP_loan < 9.31 then BIN_LOG_REP_loan=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_loan < 9.31 then BIN_LOG_REP_loan=1;
109824    +else if LOG_REP_loan < 9.69 then BIN_LOG_REP_loan=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_loan < 9.69 then BIN_LOG_REP_loan=2;
109825    +else if LOG_REP_loan < 10.05 then BIN_LOG_REP_loan=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_loan < 10.05 then BIN_LOG_REP_loan=3;
109826    +else if LOG_REP_loan >= 10.05 then BIN_LOG_REP_loan=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_loan >= 10.05 then BIN_LOG_REP_loan=4;
109827    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109828    +if LOG_REP_mortdue eq . then BIN_LOG_REP_mortdue= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_mortdue eq . then BIN_LOG_REP_mortdue= .;
109829    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109830    +if LOG_REP_mortdue < 10.75 then BIN_LOG_REP_mortdue=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_mortdue < 10.75 then BIN_LOG_REP_mortdue=1;
109831    +else if LOG_REP_mortdue < 11.08 then BIN_LOG_REP_mortdue=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_mortdue < 11.08 then BIN_LOG_REP_mortdue=2;
109832    +else if LOG_REP_mortdue < 11.45 then BIN_LOG_REP_mortdue=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_mortdue < 11.45 then BIN_LOG_REP_mortdue=3;
109833    +else if LOG_REP_mortdue >= 11.45 then BIN_LOG_REP_mortdue=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_mortdue >= 11.45 then BIN_LOG_REP_mortdue=4;
109834    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109835    +if LOG_REP_ninq eq . then BIN_LOG_REP_ninq= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_ninq eq . then BIN_LOG_REP_ninq= .;
109836    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109837    +if LOG_REP_ninq < 0 then BIN_LOG_REP_ninq=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_ninq < 0 then BIN_LOG_REP_ninq=1;
109838    +else if LOG_REP_ninq < 0.69 then BIN_LOG_REP_ninq=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_ninq < 0.69 then BIN_LOG_REP_ninq=2;
109839    +else if LOG_REP_ninq < 1.1 then BIN_LOG_REP_ninq=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_ninq < 1.1 then BIN_LOG_REP_ninq=3;
109840    +else if LOG_REP_ninq >= 1.1 then BIN_LOG_REP_ninq=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_ninq >= 1.1 then BIN_LOG_REP_ninq=4;
109841    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109842    +if LOG_REP_value eq . then BIN_LOG_REP_value= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_value eq . then BIN_LOG_REP_value= .;
109843    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109844    +if LOG_REP_value < 11.1 then BIN_LOG_REP_value=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_value < 11.1 then BIN_LOG_REP_value=1;
109845    +else if LOG_REP_value < 11.4 then BIN_LOG_REP_value=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_value < 11.4 then BIN_LOG_REP_value=2;
109846    +else if LOG_REP_value < 11.71 then BIN_LOG_REP_value=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_value < 11.71 then BIN_LOG_REP_value=3;
109847    +else if LOG_REP_value >= 11.71 then BIN_LOG_REP_value=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_value >= 11.71 then BIN_LOG_REP_value=4;
109848    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109849    +if LOG_REP_yoj eq . then BIN_LOG_REP_yoj= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_yoj eq . then BIN_LOG_REP_yoj= .;
109850    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
109851    +if LOG_REP_yoj < 1.39 then BIN_LOG_REP_yoj=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_REP_yoj < 1.39 then BIN_LOG_REP_yoj=1;
109852    +else if LOG_REP_yoj < 2.08 then BIN_LOG_REP_yoj=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_yoj < 2.08 then BIN_LOG_REP_yoj=2;
109853    +else if LOG_REP_yoj < 2.64 then BIN_LOG_REP_yoj=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_yoj < 2.64 then BIN_LOG_REP_yoj=3;
109854    +else if LOG_REP_yoj >= 2.64 then BIN_LOG_REP_yoj=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_REP_yoj >= 2.64 then BIN_LOG_REP_yoj=4;
109855    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
109856    +drop
109857    +LOG_REP_clage
109858    +LOG_REP_clno
109859    +LOG_REP_debtinc
109860    +LOG_REP_delinq
109861    +LOG_REP_derog
109862    +LOG_REP_loan
109863    +LOG_REP_mortdue
109864    +LOG_REP_ninq
109865    +LOG_REP_value
109866    +LOG_REP_yoj
109867    +;
MPRINT(EM_QUANTILE_BINNING):   drop LOG_REP_clage LOG_REP_clno LOG_REP_debtinc LOG_REP_delinq 
LOG_REP_derog LOG_REP_loan LOG_REP_mortdue LOG_REP_ninq LOG_REP_value LOG_REP_yoj ;
109868    +drop
109869    +LOG_REP_clage
109870    +LOG_REP_clno
109871    +LOG_REP_debtinc
109872    +LOG_REP_delinq
109873    +LOG_REP_derog
109874    +LOG_REP_loan
109875    +LOG_REP_mortdue
109876    +LOG_REP_ninq
109877    +LOG_REP_value
109878    +LOG_REP_yoj
109879    +;
MPRINT(EM_QUANTILE_BINNING):   drop LOG_REP_clage LOG_REP_clno LOG_REP_debtinc LOG_REP_delinq 
LOG_REP_derog LOG_REP_loan LOG_REP_mortdue LOG_REP_ninq LOG_REP_value LOG_REP_yoj ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 2979 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set EMWS1.BINNING_BINDATA has 2979 observations and 35 variables.
NOTE: DATA statement used (Total process time):
      real time           0.10 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   length newgroup _group_ _order_ 8 _level_ $8;
MPRINT(EM_QUANTILE_BINNING):   newgroup =.;
MPRINT(EM_QUANTILE_BINNING):   _LEVEL_ = 'ORDINAL';
MPRINT(EM_QUANTILE_BINNING):   _Group_ = grp;
MPRINT(EM_QUANTILE_BINNING):   rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = 
_VARIABLE_;
MPRINT(EM_QUANTILE_BINNING):   keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: 
      (Line):(Column).
      199:121   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 36 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: There were 10 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 46 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   _order_ = _N_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 46 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set WORK.TEMPSPLITVALS has 46 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals ;
MPRINT(EM_QUANTILE_BINNING):   keep display_var _split_value_ _variable_ newgroup _group_ 
_level_ _order_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 46 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 46 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempvariableset;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_QUANTILE_BINNING):   where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and 
USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 2 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL not = 'INTERVAL') and (TYPE='C') and (((ROLE='INPUT') and USE in ('D', 
      'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 2 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 1 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Thu, Nov  5, 2015 02:09:06 PM,
      Last Modified=Thu, Nov  5, 2015 02:10:43 PM,
      Filename=C:\Users\bteric01\AppData\Local\Temp\SAS Temporary 
      Files\_TD3196_COB-IT-M12_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 7 records were written to the file MACFILE.
      The minimum record length was 10.
      The maximum record length was 24.
NOTE: There were 2 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
109880    +%macro classvars;
109881    +job reason
109882    +%mend classvars;
109883    +%global num_classvars;
109884    +%let num_classvars = 2 ;
109885    +%global num_classvars;
109886    +%let num_classvars = 2 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   proc dmdb data =EMWS1.BINNING_BINDATA classout=_classout nonorm;
MPRINT(EM_QUANTILE_BINNING):   class
MPRINT(CLASSVARS):   job reason
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK._CLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc dmdb data=EMWS1.BINNING_BINDATA classout=_classout2;
MPRINT(EM_QUANTILE_BINNING):   class
MPRINT(CLASSVARS):   job reason
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK._CLASSOUT2 has 10 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=_classout;
MPRINT(EM_QUANTILE_BINNING):   by NAME CRAW;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=_classout2;
MPRINT(EM_QUANTILE_BINNING):   by NAME CRAW;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT2.
NOTE: The data set WORK._CLASSOUT2 has 10 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data _classout;
MPRINT(EM_QUANTILE_BINNING):   length _variable_ $32;
MPRINT(EM_QUANTILE_BINNING):   merge _classout _classout2 (rename=(LEVEL=_split_value_));
MPRINT(EM_QUANTILE_BINNING):   by NAME CRAW;
MPRINT(EM_QUANTILE_BINNING):   _variable_ = NAME;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: There were 10 observations read from the data set WORK._CLASSOUT2.
NOTE: The data set WORK._CLASSOUT has 10 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=_classout;
MPRINT(EM_QUANTILE_BINNING):   by _variable_ _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 10 observations and 11 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   by _variable_ _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 46 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 46 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   length _norm_level_ $200 _split_value_ $200;
MPRINT(EM_QUANTILE_BINNING):   merge EMWS1.BINNING_SPLITVALS 
_classout(rename=(LEVEL=_norm_level_));
MPRINT(EM_QUANTILE_BINNING):   by _variable_ _split_value_;
MPRINT(EM_QUANTILE_BINNING):   LEVEL = trim(left(LEVEL));
MPRINT(EM_QUANTILE_BINNING):   _split_value_ = trim(left(_split_value_));
MPRINT(EM_QUANTILE_BINNING):   _norm_level_ = trim(left(_norm_level_));
MPRINT(EM_QUANTILE_BINNING):   if _norm_level_ eq '' then _norm_level_= _split_value_;
MPRINT(EM_QUANTILE_BINNING):   drop NAME FREQUENCY TYPE CRAW NRAW;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Numeric values have been converted to character values at the places given by: 
      (Line):(Column).
      356:121   
NOTE: Character values have been converted to numeric values at the places given by: 
      (Line):(Column).
      356:111   
NOTE: There were 46 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 56 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_QUANTILE_BINNING):   delete _classout _classout2;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Deleting WORK._CLASSOUT (memtype=DATA).
NOTE: Deleting WORK._CLASSOUT2 (memtype=DATA).
MPRINT(EM_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   if _norm_level_ eq '' then _norm_level_= _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 56 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   by DISPLAY_VAR _Group_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 56 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_QUANTILE_BINNING):   delete sortedmapping tempsplitvals tempmissvalues ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.SORTEDMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and 
((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 2 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE LEVEL in ('BINARY', 'NOMINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or 
      ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 2 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc dmdb data=EMWS1.Trans_TRAIN classout=tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   class job reason ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS1.PART_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.14 seconds
      cpu time            0.14 seconds
      
NOTE: There were 2979 observations read from the data set EMWS1.REPL_TRAIN.
NOTE: There were 2979 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set WORK.TEMPCLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.17 seconds
      cpu time            0.18 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL='MISSING' then level='Missing';
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPCLASSOUT has 10 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=tempclassout nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by NAME descending FREQUENCY LEVEL;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPCLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds(keep=NAME NOBS);
MPRINT(EM_CLASSVARS_GROUP):   retain NOBS;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if first.NAME then NOBS = frequency;
MPRINT(EM_CLASSVARS_GROUP):   else NOBS=NOBS+frequency;
MPRINT(EM_CLASSVARS_GROUP):   if last.name then do;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPDS has 2 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds;
MPRINT(EM_CLASSVARS_GROUP):   merge tempclassout tempds;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if ((LEVEL ne '') AND (LEVEL ne "."));
MPRINT(EM_CLASSVARS_GROUP):   PCT = 100 * (FREQUENCY/NOBS);
MPRINT(EM_CLASSVARS_GROUP):   if PCT < 0.5 then flag=1;
MPRINT(EM_CLASSVARS_GROUP):   else flag=0;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 2 observations read from the data set WORK.TEMPDS.
NOTE: The data set WORK.TEMPDS has 8 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempmissvalues;
MPRINT(EM_CLASSVARS_GROUP):   length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
MPRINT(EM_CLASSVARS_GROUP):   NAME="job";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="reason";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 2 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempsplitvals;
MPRINT(EM_CLASSVARS_GROUP):   length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   if ((level ne '') AND (level ne '.'));
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "job" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "OTHER" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "PROFEX" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "OFFICE" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "MGR" then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "SELF" then _GROUP_ = 6;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "SALES" then _GROUP_ = 7;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 8;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "reason" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "DEBTCON" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "HOMEIMP" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   _VARIABLE_ = NAME;
MPRINT(EM_CLASSVARS_GROUP):   newgroup = .;
MPRINT(EM_CLASSVARS_GROUP):   rename NAME = DISPLAY_VAR LEVEL = _SPLIT_VALUE_;
MPRINT(EM_CLASSVARS_GROUP):   keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Variable _Split_value_ is uninitialized.
NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 2 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 10 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sql;
MPRINT(EM_CLASSVARS_GROUP):   reset noprint;
MPRINT(EM_CLASSVARS_GROUP):   select count(*) into :nobs from EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 56 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = tempsplitvals nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_Value_ _group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 10 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   merge EMWS1.BINNING_SPLITVALS tempsplitvals ;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_ ;
MPRINT(EM_CLASSVARS_GROUP):   if display_var eq "" then delete;
MPRINT(EM_CLASSVARS_GROUP):   if _norm_level_ eq "" then _norm_level_ = _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   keep display_var _split_value_ _variable_ newgroup _group_ 
_level_ _norm_level_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: There were 10 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 56 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 56 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_CLASSVARS_GROUP):   delete tempsplitvals tempds tempclassout tempvariableset 
tempvars tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPDS (memtype=DATA).
NOTE: Deleting WORK.TEMPCLASSOUT (memtype=DATA).
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_CLASSVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_ORDVARS_GROUP):   by NAME;
MPRINT(EM_ORDVARS_GROUP):   where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) 
OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is empty.
NOTE: There were 0 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='ORDINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or 
      ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 0 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_ORDVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_ORDVARS_GROUP):   delete tempsplitvals varvals tempvariableset tempvars ;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: The file WORK.TEMPSPLITVALS (memtype=DATA) was not found, but appears on a DELETE 
      statement.
NOTE: The file WORK.VARVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
MPRINT(EM_ORDVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc print data=EMWS1.BINNING_VARMAPPINGS label;
MPRINT(TRAIN):   var _VARIABLE_ _GRP_VARIABLE_ ;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The PROCEDURE PRINT printed page 50.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS1.BINNING_SPLITVALS out=tempsplitvals nodupkey;
MPRINT(TRAIN):   by _VARIABLE_;
MPRINT(TRAIN):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: 44 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 12 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   length _proc_var_ $32;
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_CLAGE" then _proc_var_ = "BIN_LOG_REP_clage";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_CLNO" then _proc_var_ = "BIN_LOG_REP_clno";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_DEBTINC" then _proc_var_ = 
"BIN_LOG_REP_debtinc";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_DELINQ" then _proc_var_ = 
"BIN_LOG_REP_delinq";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_DEROG" then _proc_var_ = "BIN_LOG_REP_derog";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_LOAN" then _proc_var_ = "BIN_LOG_REP_loan";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_MORTDUE" then _proc_var_ = 
"BIN_LOG_REP_mortdue";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_NINQ" then _proc_var_ = "BIN_LOG_REP_ninq";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_VALUE" then _proc_var_ = "BIN_LOG_REP_value";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_REP_YOJ" then _proc_var_ = "BIN_LOG_REP_yoj";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "JOB" then _proc_var_ = "job";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "REASON" then _proc_var_ = "reason";
MPRINT(TRAIN):   if missing(_proc_var_) then _proc_var_=_variable_;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 12 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete sortedbin tempsplitvals;
MPRINT(TRAIN):   run;

NOTE: The file WORK.SORTEDBIN (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_FINE_DETAIL):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_FINE_DETAIL):   table bad / missing out=temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 2979 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETB has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TEMPTARGETB (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 24 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 24 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data temptrain ;
MPRINT(EM_SUMMARIZE_TABLE):   set EMWS1.BINNING_BINDATA;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 2979 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTRAIN has 2979 observations and 35 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 
'sashelp.emapps.em_Prenormalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_PRENORMALIZECLASSVARS.SOURCE.
109887    +%macro em_PreNormalizeClassVars(incmeta=, outcmeta=);
109888    +
109889    +   data &outcmeta(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
109890    +      length INDEXVAR $32; retain _index 0;
109891    +      set &incmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and
109891   !+ USE='Y'));
109892    +      if strip(LEVEL) eq 'INTERVAL' then delete;
109893    +      else do;
109894    +         _index+1;
109895    +         INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
109896    +      end;
109897    +   run;
109898    +%mend em_PreNormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 
'sashelp.emapps.em_Normalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_NORMALIZECLASSVARS.SOURCE.
109899    +%macro em_NormalizeClassVars(indata=,
109900    +                          cmeta=,
109901    +                          encodedTarget=N,
109902    +                          target=,
109903    +                          targetEvent=,
109904    +                          targetNonEvent=,
109905    +                          outdata=);
109906    + %let dsid = %sysfunc(open(&cmeta));
109907    + %let vn_name =%sysfunc(varnum(&dsid, NAME));
109908    + %let vn_indexvar =%sysfunc(varnum(&dsid, INDEXVAR));
109909    + %let vn_format =%sysfunc(varnum(&dsid, FORMAT));
109910    + %let vn_type =%sysfunc(varnum(&dsid, TYPE));
109911    +
109912    + data &outdata/view=&outdata;
109913    +      length _normedvar32 $32.;
109914    +      set &indata( rename = (
109915    +      %let k = 1;
109916    +      %do %while(^%sysfunc(fetch(&dsid)));
109917    +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
109918    +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
109919    +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
109920    +          &_name = &_indexvar
109921    +          %let k = %eval(&k+1);
109922    +      %end;
109923    +      ));
109924    +      drop  _normedvar32;
109925    +
109926    +      %let rc=%sysfunc(rewind(&dsid));
109927    +      %let k = 1;
109928    +      %do %while(^%sysfunc(fetch(&dsid)));
109929    +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
109930    +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
109931    +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
109932    +          %let _type     = %sysfunc(getvarc(&dsid, &vn_type));
109933    +          %if &_format ne %then %do;
109934    +              _normedvar32 = put(&_indexvar, &_format);
109935    +          %end;
109936    +          %else %do;
109937    +              %if &_type = N %then %do;
109938    +                  _normedvar32 = put(&_indexvar, Best12.);
109939    +              %end;
109940    +              %else %do;
109941    +                  _normedvar32 = put(&_indexvar, $32.);
109942    +              %end;
109943    +          %end;
109944    +          %DMNORMIP(_normedvar32);
109945    +          &_name = _normedvar32;
109946    +          drop &_indexvar;
109947    +          %let k = %eval(&k+1);
109948    +      %end;
109949    +      %let dsid = %sysfunc(close(&dsid));
109950    +
109951    +      %if &encodedTarget = Y %then %do;
109952    +          %let qtargetEvent = %sysfunc(quote(&targetEvent));
109953    +          %let qtargetNonEvent = %sysfunc(quote(&targetNonEvent));
109954    +          if upcase(strip(&target)) = &qtargetEvent then _EncodedTarget_ =1;
109955    +          else if upcase(strip(&target)) = &qtargetNonEvent then _EncodedTarget_ = 0
109955   !+;
109956    +      %end;
109957    + run;
109958    +
109959    +%mend em_NormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=tempmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 12 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPMAP has 12 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _cmeta;
MPRINT(EM_SUMMARIZE_TABLE):   merge tempvarset tempmap(in=_a rename=(_variable_=name ));
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   if ((_a) or (role="TARGET"));
MPRINT(EM_SUMMARIZE_TABLE):   if role="INPUT" or (role="REJECTED" and Use="Y") then 
name=_proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if role="TARGET" then role="INPUT";
MPRINT(EM_SUMMARIZE_TABLE):   level = procLevel;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(name, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Numeric values have been converted to character values at the places given by: 
      (Line):(Column).
      82:121   
NOTE: Character values have been converted to numeric values at the places given by: 
      (Line):(Column).
      85:105   
NOTE: There were 24 observations read from the data set WORK.TEMPVARSET.
NOTE: There were 12 observations read from the data set WORK.TEMPMAP.
NOTE: The data set WORK._CMETA has 13 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRENORMALIZECLASSVARS):   data _cmetatmp(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT 
INFORMAT) ;
MPRINT(EM_PRENORMALIZECLASSVARS):   length INDEXVAR $32;
MPRINT(EM_PRENORMALIZECLASSVARS):   retain _index 0;
MPRINT(EM_PRENORMALIZECLASSVARS):   set _cmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or 
ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRENORMALIZECLASSVARS):   if strip(LEVEL) eq 'INTERVAL' then delete;
MPRINT(EM_PRENORMALIZECLASSVARS):   else do;
MPRINT(EM_PRENORMALIZECLASSVARS):   _index+1;
MPRINT(EM_PRENORMALIZECLASSVARS):   INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
MPRINT(EM_PRENORMALIZECLASSVARS):   end;
MPRINT(EM_PRENORMALIZECLASSVARS):   run;

NOTE: There were 13 observations read from the data set WORK._CMETA.
      WHERE ((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'));
NOTE: The data set WORK._CMETATMP has 13 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_NORMALIZECLASSVARS):   data _tmp_train/view=_tmp_train;
MPRINT(EM_NORMALIZECLASSVARS):   length _normedvar32 $32.;
MPRINT(EM_NORMALIZECLASSVARS):   set work.temptrain( rename = ( BIN_LOG_REP_clage = _INDEXVAR1 
BIN_LOG_REP_clno = _INDEXVAR2 BIN_LOG_REP_debtinc = _INDEXVAR3 BIN_LOG_REP_delinq = _INDEXVAR4 
BIN_LOG_REP_derog = _INDEXVAR5 BIN_LOG_REP_loan = _INDEXVAR6 BIN_LOG_REP_mortdue = _INDEXVAR7 
BIN_LOG_REP_ninq = _INDEXVAR8 BIN_LOG_REP_value = _INDEXVAR9 BIN_LOG_REP_yoj = _INDEXVAR10 bad 
= _INDEXVAR11 job = _INDEXVAR12 reason = _INDEXVAR13 ));
MPRINT(EM_NORMALIZECLASSVARS):   drop _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR1, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_clage = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR1;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR2, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_clno = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR2;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR3, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_debtinc = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR3;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR4, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_delinq = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR4;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR5, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_derog = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR5;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR6, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_loan = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR6;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR7, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_mortdue = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR7;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR8, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_ninq = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR8;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR9, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_value = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR9;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR10, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_REP_yoj = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR10;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR11, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   bad = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR11;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR12, $32.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   job = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR12;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR13, $32.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   reason = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR13;
MPRINT(EM_NORMALIZECLASSVARS):   run;

NOTE: DATA STEP view saved on file WORK._TMP_TRAIN.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=sortedmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 12 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.SORTEDMAP has 12 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output CrossTabFreqs=crosstabfreq ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("proc freq data=_tmp_train order=formatted 
addnames;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("tables ("||_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(") * bad/ missing;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   proc freq data=_tmp_train order=formatted addnames;
MPRINT(EM_SUMMARIZE_TABLE):   ) * bad/ missing;
MPRINT(EM_SUMMARIZE_TABLE):   run;
MPRINT(EM_SUMMARIZE_TABLE):   ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing;
NOTE: There were 12 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: CALL EXECUTE generated line.
1         + ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   CrossTabFreqs ;
2         + ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   close
3         + proc freq data=_tmp_train order=formatted addnames;
4         + tables (BIN_LOG_REP_clage
5         + BIN_LOG_REP_clno
6         + BIN_LOG_REP_debtinc
7         + BIN_LOG_REP_delinq
8         + BIN_LOG_REP_derog
9         + BIN_LOG_REP_loan
10        + BIN_LOG_REP_mortdue
11        + BIN_LOG_REP_ninq
12        + BIN_LOG_REP_value
13        + BIN_LOG_REP_yoj
14        + job
15        + reason
16        + ) * bad/ missing;
17        + run;

NOTE: View WORK._TMP_TRAIN.VIEW used (Total process time):
      real time           1.31 seconds
      cpu time            0.20 seconds
      
NOTE: There were 2979 observations read from the data set WORK.TEMPTRAIN.
NOTE: The data set WORK.CROSSTABFREQ has 192 observations and 23 variables.
NOTE: There were 2979 observations read from the data set WORK._TMP_TRAIN.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           1.37 seconds
      cpu time            0.26 seconds
      

18        + ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   close
19        + ods listing;
MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("data crosstabs;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  length _variable_ _split_value_  $200 ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  set crosstabfreq(where=(_type_='11'));");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _variable_= RowVariable;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' 
then do;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _split_value_="||_proc_var_||";");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("end;");
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("keep _variable_ _split_value_ bad Frequency 
Percent display_var;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabfreq(where=(_type_='11'));
MPRINT(EM_SUMMARIZE_TABLE):   _variable_= RowVariable;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_clage' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_clage ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_clno' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_clno ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_debtinc' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_debtinc ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_delinq' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_delinq ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_derog' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_derog ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_loan' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_loan ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_mortdue' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_mortdue ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_ninq' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_ninq ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_value' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_value ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_REP_yoj' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_REP_yoj ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'job' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=job ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'reason' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=reason ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   keep _variable_ _split_value_ bad Frequency Percent display_var;
MPRINT(EM_SUMMARIZE_TABLE):   run;
NOTE: There were 12 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: CALL EXECUTE generated line.
1         + data crosstabs;
2         +   length _variable_ _split_value_  $200 ;
MPRINT(EM_SUMMARIZE_TABLE):  200
3         +   set crosstabfreq(where=(_type_='11'));
4         +   _variable_= RowVariable;
5         + if strip(RowVariable) = 'BIN_LOG_REP_clage' then do;
6         +   _split_value_=BIN_LOG_REP_clage               ;
7         + end;
8         + if strip(RowVariable) = 'BIN_LOG_REP_clno' then do;
9         +   _split_value_=BIN_LOG_REP_clno                ;
10        + end;
11        + if strip(RowVariable) = 'BIN_LOG_REP_debtinc' then do;
12        +   _split_value_=BIN_LOG_REP_debtinc             ;
13        + end;
14        + if strip(RowVariable) = 'BIN_LOG_REP_delinq' then do;
15        +   _split_value_=BIN_LOG_REP_delinq              ;
16        + end;
17        + if strip(RowVariable) = 'BIN_LOG_REP_derog' then do;
18        +   _split_value_=BIN_LOG_REP_derog               ;
19        + end;
20        + if strip(RowVariable) = 'BIN_LOG_REP_loan' then do;
21        +   _split_value_=BIN_LOG_REP_loan                ;
22        + end;
23        + if strip(RowVariable) = 'BIN_LOG_REP_mortdue' then do;
24        +   _split_value_=BIN_LOG_REP_mortdue             ;
25        + end;
26        + if strip(RowVariable) = 'BIN_LOG_REP_ninq' then do;
27        +   _split_value_=BIN_LOG_REP_ninq                ;
28        + end;
29        + if strip(RowVariable) = 'BIN_LOG_REP_value' then do;
30        +   _split_value_=BIN_LOG_REP_value               ;
31        + end;
32        + if strip(RowVariable) = 'BIN_LOG_REP_yoj' then do;
33        +   _split_value_=BIN_LOG_REP_yoj                 ;
34        + end;
35        + if strip(RowVariable) = 'job' then do;
36        +   _split_value_=job                             ;
37        + end;
38        + if strip(RowVariable) = 'reason' then do;
39        +   _split_value_=reason                          ;
40        + end;
41        + keep _variable_ _split_value_ bad Frequency Percent display_var;
42        + run;

WARNING: The variable display_var in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 104 observations read from the data set WORK.CROSSTABFREQ.
      WHERE _type_='11';
NOTE: The data set WORK.CROSSTABS has 104 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 104 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 104 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length display_var $32;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs sortedmap(rename=(_variable_=display_var 
_proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 104 observations read from the data set WORK.CROSSTABS.
NOTE: There were 12 observations read from the data set WORK.SORTEDMAP.
NOTE: The data set WORK.CROSSTABS has 104 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by display_var _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 104 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 104 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 24 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 24 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs tempvarset(rename=(name=display_var) keep=type 
format name level);
MPRINT(EM_SUMMARIZE_TABLE):   by display_var;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(_variable_, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   _temp = bad;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

WARNING: Multiple lengths were specified for the BY variable display_var by input data sets. 
         This might cause unexpected results.
NOTE: There were 104 observations read from the data set WORK.CROSSTABS.
NOTE: There were 24 observations read from the data set WORK.TEMPVARSET.
NOTE: The data set WORK.CROSSTABS has 116 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 116 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 116 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 eventCount nonEventCount 
Total EventRate nonEventRate 8 type $1 valfmt $20 ;
MPRINT(EM_SUMMARIZE_TABLE):   retain eventCount noneventCount ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   if first._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total=0;
MPRINT(EM_SUMMARIZE_TABLE):   eventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   noneventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if _temp=1 then eventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   else noneventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   if last._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total = eventCount + noneventCount;
MPRINT(EM_SUMMARIZE_TABLE):   if total ne 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = eventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = nonEventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   output;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   valfmt = format;
MPRINT(EM_SUMMARIZE_TABLE):   drop _temp Frequency percent;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Character values have been converted to numeric values at the places given by: 
      (Line):(Column).
      374:126   
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      1 at 393:122   1 at 402:134   1 at 405:129   
NOTE: There were 116 observations read from the data set WORK.CROSSTABS.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 53 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):  ;
MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   length display_var $32 newgroup numsplitval 8;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   display_var = _variable_;
MPRINT(EM_FINE_DETAIL):   index = kindex(display_var, "BIN_");
MPRINT(EM_FINE_DETAIL):   if index gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 5);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   index2 = kindex(display_var, "SV_");
MPRINT(EM_FINE_DETAIL):   if index2 gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 4);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ 
= ".")) then _SPLIT_VALUE_="MISSING";
MPRINT(EM_FINE_DETAIL):   _index_ = _N_;
MPRINT(EM_FINE_DETAIL):   newgroup = .;
MPRINT(EM_FINE_DETAIL):   drop index index2 ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Variable numsplitval is uninitialized.
NOTE: There were 53 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 53 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 53 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 53 observations and 16 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   data tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_FINE_DETAIL):   _norm_level_ = upcase(_norm_level_);
MPRINT(EM_FINE_DETAIL):   if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
MPRINT(EM_FINE_DETAIL):   * drop _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.TMPSPLITVALS has 56 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=tmpsplitvals out=sortedsplit;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 56 observations read from the data set WORK.TMPSPLITVALS.
NOTE: The data set WORK.SORTEDSPLIT has 56 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets library=work nolist;
MPRINT(EM_FINE_DETAIL):   delete tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TMPSPLITVALS (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedbin;
MPRINT(EM_FINE_DETAIL):   by BIN_NAME BIN;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.SORTEDBIN has 36 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   merge EMWS1.BINNING_FINEDETAILDATA(in=_c) work.sortedsplit(in=_b) 
work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   if _a then do;
MPRINT(EM_FINE_DETAIL):   binFlag = 1;
MPRINT(EM_FINE_DETAIL):   VALUE=EM_BIN_LABEL;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   else do;
MPRINT(EM_FINE_DETAIL):   binFlag = 0;
MPRINT(EM_FINE_DETAIL):   *VALUE=strip(display_var)!!"="!!strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   VALUE=strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((eventCount=.) or (nonEventCount=.)) then do;
MPRINT(EM_FINE_DETAIL):   eventCount=0;
MPRINT(EM_FINE_DETAIL):   nonEventCount=0;
MPRINT(EM_FINE_DETAIL):   total = 0;
MPRINT(EM_FINE_DETAIL):   eventRate= 0;
MPRINT(EM_FINE_DETAIL):   nonEventRate = 0;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   eventCount = round(eventCount, .001);
MPRINT(EM_FINE_DETAIL):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_FINE_DETAIL):   total= round(total, .001);
MPRINT(EM_FINE_DETAIL):   eventRate = round(eventRate, .001);
MPRINT(EM_FINE_DETAIL):   nonEventRate = round(nonEventRate, .001);
MPRINT(EM_FINE_DETAIL):   if ((type='N') AND (VERIFY(trim(left(_split_value_)) , 
'.0123456789')=0) ) then numsplitval = _split_value_;
MPRINT(EM_FINE_DETAIL):   else if ((type='N') AND (valfmt ne "")) then numsplitval = _order_;
MPRINT(EM_FINE_DETAIL):   else numsplitval=.;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
MPRINT(EM_FINE_DETAIL):   if _a and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   if _c and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   drop NAME EM_BIN_LABEL valfmt;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Character values have been converted to numeric values at the places given by: 
      (Line):(Column).
      321:70   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 53 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: There were 56 observations read from the data set WORK.SORTEDSPLIT.
NOTE: There were 36 observations read from the data set WORK.SORTEDBIN.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 56 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_clage" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_clno" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_debtinc" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_delinq" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_derog" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_loan" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_mortdue" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_ninq" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_value" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_REP_yoj" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "job" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "reason" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then delete;
MPRINT(EM_FINE_DETAIL):   * if binFlag=1 and UB=LB then delete;
MPRINT(EM_FINE_DETAIL):   * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 56 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by DISPLAY_VAR _index_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 56 observations and 24 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete sortedsplit sortedbin ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.SORTEDSPLIT (memtype=DATA).
NOTE: Deleting WORK.SORTEDBIN (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CREATE_GROUPING):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_CREATE_GROUPING):   table bad / missing out=temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 2979 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETC has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets lib=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPTARGETC (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc means data=EMWS1.BINNING_FINEDETAILDATA noprint;
MPRINT(EM_CREATE_GROUPING):   var eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   class _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   output out=summ(where=(_type_ in(2,3))) sum=eventCount 
nonEventCount;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set WORK.SUMM has 68 observations and 6 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=summ(drop=_type_ _freq_);
MPRINT(EM_CREATE_GROUPING):   by _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 68 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.SUMM has 68 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep=_variable_ eventCount nonEventCount 
groupresprate) tempcoarse(keep=_variable_ _group_ eventCount nonEventCount groupresprate 
groupNonRespRate eventRate nonEventRate respper nrespper);
MPRINT(EM_CREATE_GROUPING):   set summ;
MPRINT(EM_CREATE_GROUPING):   *format groupresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   *format groupnonresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   by _variable_ ;
MPRINT(EM_CREATE_GROUPING):   if _group_=. then do;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   respper = eventCount / 594;
MPRINT(EM_CREATE_GROUPING):   nrespper = nonEventCount / 2385;
MPRINT(EM_CREATE_GROUPING):   if ((nonEventCount = 0) AND (eventCount = 0)) then do;
MPRINT(EM_CREATE_GROUPING):   groupresprate=0;
MPRINT(EM_CREATE_GROUPING):   groupNonresprate = 0;
MPRINT(EM_CREATE_GROUPING):   eventRate = 0;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   groupresprate = eventCount / (eventCount + nonEventCount) ;
MPRINT(EM_CREATE_GROUPING):   groupNonRespRate = 1 - groupRespRate;
MPRINT(EM_CREATE_GROUPING):   eventRate = eventCount / 594 ;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = nonEventCount / 2385 ;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   output gini tempcoarse;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 68 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.GINI has 56 observations and 4 variables.
The SAS System

NOTE: The data set WORK.TEMPCOARSE has 56 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=gini;
MPRINT(EM_CREATE_GROUPING):   by _variable_ descending groupresprate;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 56 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 56 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep= _variable_ _gini_);
MPRINT(EM_CREATE_GROUPING):   retain between within cumresp cumnresp;
MPRINT(EM_CREATE_GROUPING):   set gini(keep=_variable_ eventCount nonEventCount);
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   if first._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   between = 0;
MPRINT(EM_CREATE_GROUPING):   within = 0;
MPRINT(EM_CREATE_GROUPING):   cumresp = 0;
MPRINT(EM_CREATE_GROUPING):   cumnresp = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   between + 2 * cumnresp * eventCount;
MPRINT(EM_CREATE_GROUPING):   within + nonEventCount * eventCount;
MPRINT(EM_CREATE_GROUPING):   cumresp + eventCount;
MPRINT(EM_CREATE_GROUPING):   cumnresp + nonEventCount;
MPRINT(EM_CREATE_GROUPING):   if last._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   if ^(cumnresp=0 or cumresp=0) then do;
MPRINT(EM_CREATE_GROUPING):   _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
MPRINT(EM_CREATE_GROUPING):   output;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 56 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 12 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(EM_CREATE_GROUPING):   rename _variable_ = display_var _proc_var_ = _variable_;
MPRINT(EM_CREATE_GROUPING):   keep _variable_ _proc_var_ label;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 12 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPDISPLAYVAR has 12 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: The data set WORK.TEMPDISPLAYVAR has 12 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data EMWS1.BINNING_COARSE;
MPRINT(EM_CREATE_GROUPING):   length display_Var $32 label _label_ $200 role $10 _group_ 8;
MPRINT(EM_CREATE_GROUPING):   merge tempdisplayvar tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   label display_var = "Variable" eventRate = "Event Rate" 
nonEventRate = "Non-Event Rate" _group_ = "Group" role = "Role" _gini_ = "Gini Coefficient" 
eventcount = "Event Count" noneventcount = "Non-Event Count" groupresprate = "Group Event 
Rate" groupnonresprate = "Group Non-Event Rate" ;
MPRINT(EM_CREATE_GROUPING):   eventCount = round(eventCount, .001);
MPRINT(EM_CREATE_GROUPING):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_CREATE_GROUPING):   groupRespRate = round(groupRespRate, .001);
MPRINT(EM_CREATE_GROUPING):   drop _variable_ index index2 respper nrespper;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Variable _label_ is uninitialized.
NOTE: Variable role is uninitialized.
WARNING: Multiple lengths were specified for the BY variable _variable_ by input data sets. 
         This might cause unexpected results.
WARNING: The variable index in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable index2 in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 12 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: There were 56 observations read from the data set WORK.TEMPCOARSE.
NOTE: There were 12 observations read from the data set WORK.GINI.
NOTE: The data set EMWS1.BINNING_COARSE has 56 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.12 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets library=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPCOARSE (memtype=DATA).
NOTE: Deleting WORK.GINI (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y 
"C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\GROUPMAPPING
SCORECODE.sas";
MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   FILE Y;
MPRINT(EM_GENERATE_LABELVALUES):   put " length _LABEL_ $200;";
MPRINT(EM_GENERATE_LABELVALUES):   put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, 
rpt_groupvalues_vlabel , NOQUOTE))";';
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: The file Y is:
      
      Filename=C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNIN
      G\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=05Nov2015:14:10:48,
      Create Time=05Nov2015:05:45:03

NOTE: 2 records were written to the file Y.
      The minimum record length was 21.
      The maximum record length was 83.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_SPLITVALS 
out=work.sortedsplitval;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var _split_Value_;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.SORTEDSPLITVAL has 56 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var bin;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 36 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a) 
EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) ne 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   if display_var eq '' then delete;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 56 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 36 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP has 44 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) 
EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) eq 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   keep _variable_ display_var missgrp;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 56 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 36 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP_MISSING has 12 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=temp out=class;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_ LB;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 44 observations read from the data set WORK.TEMP.
NOTE: The data set WORK.CLASS has 44 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   file Y MOD;
MPRINT(EM_GENERATE_LABELVALUES):   length string $200 flag 8;
MPRINT(EM_GENERATE_LABELVALUES):   retain string flag;
MPRINT(EM_GENERATE_LABELVALUES):   set class end=eof;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_;
MPRINT(EM_GENERATE_LABELVALUES):   index = kindex(_variable_, "BIN_");
MPRINT(EM_GENERATE_LABELVALUES):   if index gt 0 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and 
_GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then do;';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   if LB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= 
"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 1;
MPRINT(EM_GENERATE_LABELVALUES):   *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._Group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   if UB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!'< '!!strip(UB)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag=1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string= " UB="!!strip(UB)!!";";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   put "end;";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _split_value_ = tranwrd(_split_value_,"'","''");
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and 
_GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string = "_LABEL_='"!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag ne 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   tempstring = strip(string)!!', '!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   length = length(tempstring);
MPRINT(EM_GENERATE_LABELVALUES):   if length < 195 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = tempstring;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)||",...";
MPRINT(EM_GENERATE_LABELVALUES):   flag=1;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Numeric values have been converted to character values at the places given by: 
      (Line):(Column).
      171:84    206:151   246:25    
NOTE: The file Y is:
      
      Filename=C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNIN
      G\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=4680,
      Last Modified=05Nov2015:14:10:48,
      Create Time=05Nov2015:05:45:03

NOTE: 204 records were written to the file Y.
      The minimum record length was 1.
      The maximum record length was 57.
NOTE: There were 44 observations read from the data set WORK.CLASS.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
NOTE: %INCLUDE (level 1) file Y is file 
      C:\Users\bteric01\Documents\Tutorials_Projects\Project_3\Workspaces\EMWS1\BINNING\GROUPMA
      PPINGSCORECODE.sas.
109960    + length _LABEL_ $200;
MPRINT(EM_GENERATE_LABELVALUES):   length _LABEL_ $200;
109961    + label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";
MPRINT(EM_GENERATE_LABELVALUES):   label _LABEL_= "Group Values";
109962    +
109963    +if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 2 then do;
109964    +_LABEL_='LOG_REP_clage< 4.76';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_clage< 4.76';
109965    +UB=4.76;
MPRINT(EM_GENERATE_LABELVALUES):   UB=4.76;
109966    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
109967    +else
109968    +if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 3 then do;
109969    +_LABEL_='4.76<= LOG_REP_clage< 5.17';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='4.76<= LOG_REP_clage< 5.17';
109970    +UB=5.17;
MPRINT(EM_GENERATE_LABELVALUES):   UB=5.17;
109971    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
109972    +else
109973    +if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 4 then do;
109974    +_LABEL_='5.17<= LOG_REP_clage< 5.45';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='5.17<= LOG_REP_clage< 5.45';
109975    +UB=5.45;
MPRINT(EM_GENERATE_LABELVALUES):   UB=5.45;
109976    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
109977    +else
109978    +if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 5 then do;
109979    +_LABEL_='5.45<= LOG_REP_clage';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='5.45<= LOG_REP_clage';
109980    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
109981    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
109982    +
109983    +if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 2 then do;
109984    +_LABEL_='LOG_REP_clno< 2.71';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_clno< 2.71';
109985    +UB=2.71;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2.71;
109986    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
109987    +else
109988    +if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 3 then do;
109989    +_LABEL_='2.71<= LOG_REP_clno< 3.04';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2.71<= LOG_REP_clno< 3.04';
109990    +UB=3.04;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.04;
109991    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
109992    +else
109993    +if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 4 then do;
109994    +_LABEL_='3.04<= LOG_REP_clno< 3.3';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.04<= LOG_REP_clno< 3.3';
109995    +UB=3.3;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.3;
109996    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
109997    +else
109998    +if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 5 then do;
109999    +_LABEL_='3.3<= LOG_REP_clno';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.3<= LOG_REP_clno';
110000    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110001    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110002    +
110003    +if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 2 then do;
110004    +_LABEL_='LOG_REP_debtinc< 3.4';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_debtinc< 3.4';
110005    +UB=3.4;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.4;
110006    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110007    +else
110008    +if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 3 then 
do;
110009    +_LABEL_='3.4<= LOG_REP_debtinc< 3.58';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.4<= LOG_REP_debtinc< 3.58';
110010    +UB=3.58;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.58;
110011    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110012    +else
110013    +if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 4 then 
do;
110014    +_LABEL_='3.58<= LOG_REP_debtinc< 3.69';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.58<= LOG_REP_debtinc< 3.69';
110015    +UB=3.69;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.69;
110016    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110017    +else
110018    +if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 5 then 
do;
110019    +_LABEL_='3.69<= LOG_REP_debtinc';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.69<= LOG_REP_debtinc';
110020    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110021    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110022    +
110023    +if DISPLAY_VAR='LOG_REP_delinq' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_delinq' and _GROUP_ = 2 then do;
110024    +_LABEL_='LOG_REP_delinq< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_delinq< 0';
110025    +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
110026    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110027    +else
110028    +if DISPLAY_VAR='LOG_REP_delinq' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_delinq' and _GROUP_ = 3 then 
do;
110029    +_LABEL_='0<= LOG_REP_delinq';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= LOG_REP_delinq';
110030    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110031    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110032    +
110033    +if DISPLAY_VAR='LOG_REP_derog' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_derog' and _GROUP_ = 2 then do;
110034    +_LABEL_='LOG_REP_derog< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_derog< 0';
110035    +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
110036    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110037    +else
110038    +if DISPLAY_VAR='LOG_REP_derog' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_derog' and _GROUP_ = 3 then do;
110039    +_LABEL_='0<= LOG_REP_derog';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= LOG_REP_derog';
110040    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110041    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110042    +
110043    +if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 2 then do;
110044    +_LABEL_='LOG_REP_loan< 9.31';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_loan< 9.31';
110045    +UB=9.31;
MPRINT(EM_GENERATE_LABELVALUES):   UB=9.31;
110046    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110047    +else
110048    +if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 3 then do;
110049    +_LABEL_='9.31<= LOG_REP_loan< 9.69';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='9.31<= LOG_REP_loan< 9.69';
110050    +UB=9.69;
MPRINT(EM_GENERATE_LABELVALUES):   UB=9.69;
110051    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110052    +else
110053    +if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 4 then do;
110054    +_LABEL_='9.69<= LOG_REP_loan< 10.05';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='9.69<= LOG_REP_loan< 10.05';
110055    +UB=10.05;
MPRINT(EM_GENERATE_LABELVALUES):   UB=10.05;
110056    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110057    +else
110058    +if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 5 then do;
110059    +_LABEL_='10.05<= LOG_REP_loan';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='10.05<= LOG_REP_loan';
110060    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110061    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110062    +
110063    +if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 2 then do;
110064    +_LABEL_='LOG_REP_mortdue< 10.75';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_mortdue< 10.75';
110065    +UB=10.75;
MPRINT(EM_GENERATE_LABELVALUES):   UB=10.75;
110066    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110067    +else
110068    +if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 3 then 
do;
110069    +_LABEL_='10.75<= LOG_REP_mortdue< 11.08';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='10.75<= LOG_REP_mortdue< 11.08';
110070    +UB=11.08;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.08;
110071    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110072    +else
110073    +if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 4 then 
do;
110074    +_LABEL_='11.08<= LOG_REP_mortdue< 11.45';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.08<= LOG_REP_mortdue< 11.45';
110075    +UB=11.45;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.45;
110076    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110077    +else
110078    +if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 5 then 
do;
110079    +_LABEL_='11.45<= LOG_REP_mortdue';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.45<= LOG_REP_mortdue';
110080    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110081    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110082    +
110083    +if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 2 then do;
110084    +_LABEL_='LOG_REP_ninq< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_ninq< 0';
110085    +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
110086    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110087    +else
110088    +if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 3 then do;
110089    +_LABEL_='0<= LOG_REP_ninq< 0.69';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= LOG_REP_ninq< 0.69';
110090    +UB=0.69;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0.69;
110091    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110092    +else
110093    +if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 4 then do;
110094    +_LABEL_='0.69<= LOG_REP_ninq< 1.1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0.69<= LOG_REP_ninq< 1.1';
110095    +UB=1.1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1.1;
110096    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110097    +else
110098    +if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 5 then do;
110099    +_LABEL_='1.1<= LOG_REP_ninq';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1.1<= LOG_REP_ninq';
110100    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110101    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110102    +
110103    +if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 2 then do;
110104    +_LABEL_='LOG_REP_value< 11.1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_value< 11.1';
110105    +UB=11.1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.1;
110106    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110107    +else
110108    +if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 3 then do;
110109    +_LABEL_='11.1<= LOG_REP_value< 11.4';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.1<= LOG_REP_value< 11.4';
110110    +UB=11.4;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.4;
110111    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110112    +else
110113    +if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 4 then do;
110114    +_LABEL_='11.4<= LOG_REP_value< 11.71';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.4<= LOG_REP_value< 11.71';
110115    +UB=11.71;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.71;
110116    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110117    +else
110118    +if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 5 then do;
110119    +_LABEL_='11.71<= LOG_REP_value';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.71<= LOG_REP_value';
110120    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110121    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110122    +
110123    +if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 2 then do;
110124    +_LABEL_='LOG_REP_yoj< 1.39';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_yoj< 1.39';
110125    +UB=1.39;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1.39;
110126    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110127    +else
110128    +if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 3 then do;
110129    +_LABEL_='1.39<= LOG_REP_yoj< 2.08';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1.39<= LOG_REP_yoj< 2.08';
110130    +UB=2.08;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2.08;
110131    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110132    +else
110133    +if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 4 then do;
110134    +_LABEL_='2.08<= LOG_REP_yoj< 2.64';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2.08<= LOG_REP_yoj< 2.64';
110135    +UB=2.64;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2.64;
110136    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110137    +else
110138    +if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 5 then do;
110139    +_LABEL_='2.64<= LOG_REP_yoj';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2.64<= LOG_REP_yoj';
110140    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110141    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110142    +
110143    +if DISPLAY_VAR='job' and _GROUP_ = 2 then
110144    +_LABEL_='OTHER';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='job' and _GROUP_ = 2 then _LABEL_='OTHER';
110145    +else
110146    +if DISPLAY_VAR='job' and _GROUP_ = 3 then
110147    +_LABEL_='PROFEX';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 3 then 
_LABEL_='PROFEX';
110148    +else
110149    +if DISPLAY_VAR='job' and _GROUP_ = 4 then
110150    +_LABEL_='OFFICE';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 4 then 
_LABEL_='OFFICE';
110151    +else
110152    +if DISPLAY_VAR='job' and _GROUP_ = 5 then
110153    +_LABEL_='MGR';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 5 then 
_LABEL_='MGR';
110154    +else
110155    +if DISPLAY_VAR='job' and _GROUP_ = 6 then
110156    +_LABEL_='SELF';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 6 then 
_LABEL_='SELF';
110157    +else
110158    +if DISPLAY_VAR='job' and _GROUP_ = 7 then
110159    +_LABEL_='SALES';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 7 then 
_LABEL_='SALES';
110160    +
110161    +if DISPLAY_VAR='reason' and _GROUP_ = 2 then
110162    +_LABEL_='DEBTCON';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='reason' and _GROUP_ = 2 then 
_LABEL_='DEBTCON';
110163    +else
110164    +if DISPLAY_VAR='reason' and _GROUP_ = 3 then
110165    +_LABEL_='HOMEIMP';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='reason' and _GROUP_ = 3 then 
_LABEL_='HOMEIMP';
110166    +
110167    +if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 2 then do;
110168    +_LABEL_='LOG_REP_clage< 4.76';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_clage< 4.76';
110169    +UB=4.76;
MPRINT(EM_GENERATE_LABELVALUES):   UB=4.76;
110170    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110171    +else
110172    +if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 3 then do;
110173    +_LABEL_='4.76<= LOG_REP_clage< 5.17';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='4.76<= LOG_REP_clage< 5.17';
110174    +UB=5.17;
MPRINT(EM_GENERATE_LABELVALUES):   UB=5.17;
110175    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110176    +else
110177    +if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 4 then do;
110178    +_LABEL_='5.17<= LOG_REP_clage< 5.45';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='5.17<= LOG_REP_clage< 5.45';
110179    +UB=5.45;
MPRINT(EM_GENERATE_LABELVALUES):   UB=5.45;
110180    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110181    +else
110182    +if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clage' and _GROUP_ = 5 then do;
110183    +_LABEL_='5.45<= LOG_REP_clage';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='5.45<= LOG_REP_clage';
110184    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110185    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110186    +
110187    +if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 2 then do;
110188    +_LABEL_='LOG_REP_clno< 2.71';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_clno< 2.71';
110189    +UB=2.71;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2.71;
110190    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110191    +else
110192    +if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 3 then do;
110193    +_LABEL_='2.71<= LOG_REP_clno< 3.04';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2.71<= LOG_REP_clno< 3.04';
110194    +UB=3.04;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.04;
110195    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110196    +else
110197    +if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 4 then do;
110198    +_LABEL_='3.04<= LOG_REP_clno< 3.3';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.04<= LOG_REP_clno< 3.3';
110199    +UB=3.3;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.3;
110200    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110201    +else
110202    +if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_clno' and _GROUP_ = 5 then do;
110203    +_LABEL_='3.3<= LOG_REP_clno';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.3<= LOG_REP_clno';
110204    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110205    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110206    +
110207    +if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 2 then do;
110208    +_LABEL_='LOG_REP_debtinc< 3.4';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_debtinc< 3.4';
110209    +UB=3.4;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.4;
110210    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110211    +else
110212    +if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 3 then 
do;
110213    +_LABEL_='3.4<= LOG_REP_debtinc< 3.58';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.4<= LOG_REP_debtinc< 3.58';
110214    +UB=3.58;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.58;
110215    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110216    +else
110217    +if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 4 then 
do;
110218    +_LABEL_='3.58<= LOG_REP_debtinc< 3.69';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.58<= LOG_REP_debtinc< 3.69';
110219    +UB=3.69;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.69;
110220    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110221    +else
110222    +if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_debtinc' and _GROUP_ = 5 then 
do;
110223    +_LABEL_='3.69<= LOG_REP_debtinc';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.69<= LOG_REP_debtinc';
110224    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110225    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110226    +
110227    +if DISPLAY_VAR='LOG_REP_delinq' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_delinq' and _GROUP_ = 2 then do;
110228    +_LABEL_='LOG_REP_delinq< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_delinq< 0';
110229    +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
110230    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110231    +else
110232    +if DISPLAY_VAR='LOG_REP_delinq' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_delinq' and _GROUP_ = 3 then 
do;
110233    +_LABEL_='0<= LOG_REP_delinq';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= LOG_REP_delinq';
110234    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110235    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110236    +
110237    +if DISPLAY_VAR='LOG_REP_derog' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_derog' and _GROUP_ = 2 then do;
110238    +_LABEL_='LOG_REP_derog< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_derog< 0';
110239    +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
110240    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110241    +else
110242    +if DISPLAY_VAR='LOG_REP_derog' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_derog' and _GROUP_ = 3 then do;
110243    +_LABEL_='0<= LOG_REP_derog';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= LOG_REP_derog';
110244    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110245    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110246    +
110247    +if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 2 then do;
110248    +_LABEL_='LOG_REP_loan< 9.31';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_loan< 9.31';
110249    +UB=9.31;
MPRINT(EM_GENERATE_LABELVALUES):   UB=9.31;
110250    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110251    +else
110252    +if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 3 then do;
110253    +_LABEL_='9.31<= LOG_REP_loan< 9.69';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='9.31<= LOG_REP_loan< 9.69';
110254    +UB=9.69;
MPRINT(EM_GENERATE_LABELVALUES):   UB=9.69;
110255    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110256    +else
110257    +if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 4 then do;
110258    +_LABEL_='9.69<= LOG_REP_loan< 10.05';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='9.69<= LOG_REP_loan< 10.05';
110259    +UB=10.05;
MPRINT(EM_GENERATE_LABELVALUES):   UB=10.05;
110260    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110261    +else
110262    +if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_loan' and _GROUP_ = 5 then do;
110263    +_LABEL_='10.05<= LOG_REP_loan';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='10.05<= LOG_REP_loan';
110264    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110265    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110266    +
110267    +if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 2 then do;
110268    +_LABEL_='LOG_REP_mortdue< 10.75';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_mortdue< 10.75';
110269    +UB=10.75;
MPRINT(EM_GENERATE_LABELVALUES):   UB=10.75;
110270    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110271    +else
110272    +if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 3 then 
do;
110273    +_LABEL_='10.75<= LOG_REP_mortdue< 11.08';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='10.75<= LOG_REP_mortdue< 11.08';
110274    +UB=11.08;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.08;
110275    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110276    +else
110277    +if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 4 then 
do;
110278    +_LABEL_='11.08<= LOG_REP_mortdue< 11.45';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.08<= LOG_REP_mortdue< 11.45';
110279    +UB=11.45;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.45;
110280    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110281    +else
110282    +if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_mortdue' and _GROUP_ = 5 then 
do;
110283    +_LABEL_='11.45<= LOG_REP_mortdue';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.45<= LOG_REP_mortdue';
110284    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110285    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110286    +
110287    +if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 2 then do;
110288    +_LABEL_='LOG_REP_ninq< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_ninq< 0';
110289    +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
110290    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110291    +else
110292    +if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 3 then do;
110293    +_LABEL_='0<= LOG_REP_ninq< 0.69';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= LOG_REP_ninq< 0.69';
110294    +UB=0.69;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0.69;
110295    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110296    +else
110297    +if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 4 then do;
110298    +_LABEL_='0.69<= LOG_REP_ninq< 1.1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0.69<= LOG_REP_ninq< 1.1';
110299    +UB=1.1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1.1;
110300    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110301    +else
110302    +if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_ninq' and _GROUP_ = 5 then do;
110303    +_LABEL_='1.1<= LOG_REP_ninq';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1.1<= LOG_REP_ninq';
110304    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110305    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110306    +
110307    +if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 2 then do;
110308    +_LABEL_='LOG_REP_value< 11.1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_value< 11.1';
110309    +UB=11.1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.1;
110310    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110311    +else
110312    +if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 3 then do;
110313    +_LABEL_='11.1<= LOG_REP_value< 11.4';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.1<= LOG_REP_value< 11.4';
110314    +UB=11.4;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.4;
110315    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110316    +else
110317    +if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 4 then do;
110318    +_LABEL_='11.4<= LOG_REP_value< 11.71';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.4<= LOG_REP_value< 11.71';
110319    +UB=11.71;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.71;
110320    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110321    +else
110322    +if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_value' and _GROUP_ = 5 then do;
110323    +_LABEL_='11.71<= LOG_REP_value';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.71<= LOG_REP_value';
110324    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110325    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110326    +
110327    +if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 2 then do;
110328    +_LABEL_='LOG_REP_yoj< 1.39';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_REP_yoj< 1.39';
110329    +UB=1.39;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1.39;
110330    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110331    +else
110332    +if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 3 then do;
110333    +_LABEL_='1.39<= LOG_REP_yoj< 2.08';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1.39<= LOG_REP_yoj< 2.08';
110334    +UB=2.08;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2.08;
110335    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110336    +else
110337    +if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 4 then do;
110338    +_LABEL_='2.08<= LOG_REP_yoj< 2.64';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2.08<= LOG_REP_yoj< 2.64';
110339    +UB=2.64;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2.64;
110340    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110341    +else
110342    +if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_REP_yoj' and _GROUP_ = 5 then do;
110343    +_LABEL_='2.64<= LOG_REP_yoj';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2.64<= LOG_REP_yoj';
110344    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
110345    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
110346    +
110347    +if DISPLAY_VAR='job' and _GROUP_ = 2 then
110348    +_LABEL_='OTHER';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='job' and _GROUP_ = 2 then _LABEL_='OTHER';
110349    +else
110350    +if DISPLAY_VAR='job' and _GROUP_ = 3 then
110351    +_LABEL_='PROFEX';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 3 then 
_LABEL_='PROFEX';
110352    +else
110353    +if DISPLAY_VAR='job' and _GROUP_ = 4 then
110354    +_LABEL_='OFFICE';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 4 then 
_LABEL_='OFFICE';
110355    +else
110356    +if DISPLAY_VAR='job' and _GROUP_ = 5 then
110357    +_LABEL_='MGR';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 5 then 
_LABEL_='MGR';
110358    +else
110359    +if DISPLAY_VAR='job' and _GROUP_ = 6 then
110360    +_LABEL_='SELF';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 6 then 
_LABEL_='SELF';
110361    +else
110362    +if DISPLAY_VAR='job' and _GROUP_ = 7 then
110363    +_LABEL_='SALES';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='job' and _GROUP_ = 7 then 
_LABEL_='SALES';
110364    +
110365    +if DISPLAY_VAR='reason' and _GROUP_ = 2 then
110366    +_LABEL_='DEBTCON';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='reason' and _GROUP_ = 2 then 
_LABEL_='DEBTCON';
110367    +else
110368    +if DISPLAY_VAR='reason' and _GROUP_ = 3 then
110369    +_LABEL_='HOMEIMP';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='reason' and _GROUP_ = 3 then 
_LABEL_='HOMEIMP';
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 56 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.07 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   *filename Y;
MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_clage" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_clno" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_debtinc" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_delinq" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_derog" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_loan" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_mortdue" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_ninq" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_value" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_REP_yoj" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "job" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "reason" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   drop ub;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 56 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 56 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc datasets library=work nolist;
MPRINT(EM_GENERATE_LABELVALUES):   delete class temp temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Deleting WORK.CLASS (memtype=DATA).
NOTE: Deleting WORK.TEMP (memtype=DATA).
NOTE: Deleting WORK.TEMP_MISSING (memtype=DATA).
MPRINT(EM_GENERATE_LABELVALUES):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y;
NOTE: Fileref Y has been deassigned.
MPRINT(EM_MODEL):   data WORK.EM_USER_MODEL;
MPRINT(EM_MODEL):   length DATA $65 TARGET $32 PREDICTED ASSESS DECSCORECODE FITSTATISTICS 
CLASSIFICATION RESIDUALS $1;
MPRINT(EM_MODEL):   data = "";
MPRINT(EM_MODEL):   target = "bad";
MPRINT(EM_MODEL):   predicted = "Y";
MPRINT(EM_MODEL):   assess = "N";
MPRINT(EM_MODEL):   decscorecode = "N";
MPRINT(EM_MODEL):   fitstatistics = "N";
MPRINT(EM_MODEL):   classification = "N";
MPRINT(EM_MODEL):   residuals = "N";
MPRINT(EM_MODEL):   run;

NOTE: The data set WORK.EM_USER_MODEL has 1 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   retain id 0;
MPRINT(EM_REPORT):   id + 1;
MPRINT(EM_REPORT):   length VIEW 8 NAME $32 VALUE $400;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "COARSE";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "DATA";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "EVENTRATESTAT";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "MODEL";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.15343858495049;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   run;

NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.09 seconds
      

MPRINT(TRAIN):  ;
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
110370     *------------------------------------------------------------*;
110371     * End TRAIN: BINNING;
110372     *------------------------------------------------------------*;
110373     

110374     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
110375     * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
110376     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
110377     ;
MPRINT(EM_DIAGRAM):   ;
110378     ;
MPRINT(EM_DIAGRAM):   ;
110379     ;
MPRINT(EM_DIAGRAM):   ;
110380     ;
MPRINT(EM_DIAGRAM):   ;
110381     quit;
MPRINT(EM_DIAGRAM):   quit;
110382     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
110383     * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
110384     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
110385     /*; *"; *'; */
110386     ;
MPRINT(EM_DIAGRAM):   ;
110387     run;
MPRINT(EM_DIAGRAM):   run;
110388     quit;
MPRINT(EM_DIAGRAM):   quit;
110389     /* Reset EM Options */
110390     options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
110391     options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
110392     goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
110393     proc sort data=WORK.EM_USER_REPORT;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_USER_REPORT;
110394     by ID VIEW;
MPRINT(EM_DIAGRAM):   by ID VIEW;
110395     run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
